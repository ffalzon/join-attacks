\section{Identifier Intersection Recovery with $\calF_{\LMKPM}$}\label{sec:st-mkpm-attack}

We now explore how the additional leakage of $\calF_{\LMKPM}$ output to $\tP_1$ enables more powerful attacks with stronger recovery goals. Specifically, we adapt Guo et al.'s search tree approach~\cite{USENIX:GHLWJL22}, initially designed for $\calF_{\PSICA}$, to recover the identifiers shared between the party inputs and achieve \emph{identifier intersection recovery} (Definition~\ref{def:IRR_goal}). In the full version, we additionally show how to recover the multiplicities of each identifier.

In this section, we restrict the adversary to using only subsets of its target set $T$ as input and assume that all records in $T$ are of equal length $\lambda \in \NN$. The adversary aims to compute two sets: $\posSet := \Ispace{T} \cap \Ispace{Y}$ and $\negSet := \Ispace{T} \setminus \Ispace{Y}$. This contrasts with the attacks discussed in Section~\ref{sec:lmkpm-attacks}, where the adversary can append or rearrange identifiers within records.

Recall that the functionality $\calF_{\LMKPM}(X;Y)$ outputs $\UID, \MX,$ $(\hXone,\hYone)$ to $\tP_1$ and $\UID, \MY, \hXtwo$ to $P_2$. For convenience, we denote the additional leakage output to $\tP_1$ when evaluating $\calF_{\LMKPM}(X;Y)$ as $(\leak^1_X, \leak^1_Y)=(\hXone,\hYone)$. This will allow us to directly refer to the leakage produced by specific inputs.

Our adapted attack starts by constructing a binary search tree $\calT$ of the target set $T$, following the method in~\cite{USENIX:GHLWJL22}. Specifically, the tree's root node corresponds to the entire target set $T$. Each node $v$ in the tree is associated with a subset of records, denoted as $v.\treeSet \subseteq T$. The two child nodes of $v$, denoted as $v_L \gets v.\treeLeftChild$ and $v_R \gets v.\treeRightChild$, correspond to a partition of the parent node's set, such that $v_L.\treeSet \cup v_R.\treeSet = v.\treeSet$ and $v_L.\treeSet \cap v_R.\treeSet = \emptyset$ .

The main challenge of adapting the $\calF_{\PSICA}$ attack to $\calF_{\MKPM}$ lies in inferring information about some node's sibling. 
Let $X \subseteq T$ be a set of records and $X_1, X_2$ be a partition of $X$.
Inferring the leakage $(\leakX{2}, \leakY)$ given $(\leakX{1}, \leakY)$ and $(\leakX{}, \leakY)$, as is analgously done in the original PSI-CA attack (for sets of elements), is non-trivial. Concretely, it involves identifying the records of $\leakX{1}$ within $\leakX{}$ which are computed with different randomness. 
Comparing the hidden identifiers of $\leakX{}$ and $\leakX{1}$ is thus not possible.
% Moreover, trying to locate the pattern of matching identifiers between $\leak_{\setX_1}$ and $\leak^{'}_\setV$ 
% within that of the matches between $\leakX$ and \leakV{} 
% does not have a unique solution in general.
% Furthermore, performing (potentially multiple) protocol invocations to solve this problems
% would raise both expected number of necessary protocol invocations, as well as the theoretical upper bound thereof,
% since this problem needs to be solved at every node encountered during a DFS path traversal.
% This is therefore an undesirable strategy.

We can find a much more tractable approach when considering an aggregate metric of the protocol leakage, namely, the number of matched identifiers per column of $\leakX{}$ and $\leakX{1}$ respectively:
\[
    \colCA(\leakX{}, \leakY) := \left(\sum_{\bt\in\leakX{}}\mathbbm{1}\{\bt[1] \in \Ispace{\leakY}\}, \dots, \sum_{\bt\in\leakX{}}\mathbbm{1}\{\bt[\lambda] \in \Ispace{\leakY}\}\right)
\]

\begin{proposition}
	\label{prop:mkpsi_equiv}
	For any two sets of records $X$ and $Y$, we have
	\begin{equation*}
		\colCA(\leakX{}, \leakY) = \colCA(X, Y).
	\end{equation*}
\end{proposition}

\begin{proposition}
	\label{prop:mkpsi_inference}
	Let $X$ and $Y$ be sets of records, and let $X_1 \cup X_2$ be a partition of $X$. Then we have
	\begin{equation*}
		\colCA(\leakX{}, \leakY)
		= \colCA(\leakX{1}, \leakY) + \colCA(\leakX{2}, \leakY)\footnote{We use standard vector operations; addition and subtraction are applied element-wise.}.
	\end{equation*}
\end{proposition}

The proofs can be found in Appendix~\ref{proof:mkpsi_equiv} and~\ref{proof:mkpsi_inference}, respectively.

From Prop.~\ref{prop:mkpsi_inference} we obtain $\colCA(\leakX{2}, \leakY)
  = \colCA(\leakX{}, \leakY) - \colCA(\leakX{1}, \leakY).$
Here, $\leakX{2}$ denotes the (hypothetical) leakage that would result from a protocol run on $X_2$, which is never actually executed. This is acceptable, since we only require $\colCA(\leakX{2}, \leakY)$ for the attack, and this vector can be inferred without knowing $\leakX{2}$ explicitly.

For a leaf node storing a single record $\bx$, i.e., $X = \{\bx\}$, each entry of the vector $\colCA(\leakX{}, \leakY)$ is either $0$ or $1$, which exactly indicates whether the corresponding identifier of $\bx$ appears in $Y$. This logic extends to larger sets: once $\colCA(\leakX{}, \leakY) \in \{0, |X|\}^{\lambda}$ for some $X$, Prop.~\ref{prop:mkpsi_equiv} implies that, for each column, either all or none of the identifiers in that column of $X$ occur in $Y$, depending on whether the corresponding entry of $\colCA(\leakX{}, \leakY)$ equals $|X|$ or $0$, respectively.
%See \cref{fig:mkpsi_early_termination_exmp} for an example.

The remaining component of our adapted attack is a heuristic that (i) decides which child to follow during DFS traversal and (ii) provides the priority for enqueuing the other child. For any set $X$, this heuristic must be computable from $X$ and $\colCA(\leakX{}, \leakY)$ alone, since this is all we know about the (hypothetical) leakage for that node. For $\bc = \colCA(\leakX{}, \leakY)$, we define
\begin{equation}
      p_{MK}^+(\bc, X) := \frac{\sum_{x \in \bc} x}{\lambda |X|}.
\end{equation}
As in the original PSI-CA attack, our heuristic prioritizes the child node whose subsets contain more matched identifiers, which increases the fraction of the intersection that can be recovered when the adversary is limited to a bounded number of protocol invocations.
We additionally propose two further heuristics in~\ref{ap:IRR:heuristics} and evaluate our three heuristics in Appendix~\ref{ap:evaluation}. 

The pseudocode of \mkpsiattack{} is given in Figure~\ref{fig:MKPSIattack} (Appendix~\ref{ap:IRR}).
The attack is similar to the original PSI-CA attack, with the difference that we maintain two sets $\posSet$ and $\negSet$ to keep track of the inferred positive and negative membership information.

\begin{theorem}\label{thm:IRR-attack-correctness}
	Let $T$ be a target set of records and $Y$ be the recovery set of records. 
    Then $\mkpsiattack^{\calF_{\LMKPM}(\cdot;Y)}(T)$~(Figure~~\ref{fig:MKPSIattack}) achieves identifier intersection recovery (Def.~\ref{def:IRR_goal}).
\end{theorem}

The proof can be found in Appendix~\ref{proof:IRR-attack-correctness}.

\heading{Time and query complexity.} 
Let $n = |T|$, $m = |Y|$, and let $\lambda$ denote the maximum record length in $T$ and $Y$.
We assume $n$ is a power of two and that priority-queue operations \push{} and \pop{} each take amortized time \bigO{\log n}.
Half of the nodes at each depth are inserted into the queue, yielding $n$ \push{} operations in total.
Since the attack terminates when the queue is empty, there are also $n$ \pop{} operations, for a total of \bigO{n \log n} time.

Given inputs $X$ of size $a$ and $Y$ of size $b$, $\colCA(X, Y)$ can be computed in expected time \bigO{\lambda(a+b)}.
It is invoked once at the root and for half of the nodes at each depth, giving an expected total cost of $\bigO{\lambda n(\log n + m)}$.
The cost of computing the heuristic $p_{MK}$ is dominated by these terms, so the overall expected runtime of \mkpsiattack{} is $\bigO{\lambda n(\log n + m)}$

Like the original PSI-CA attack, \mkpsiattack{} requires at most $n$ protocol invocations, though this bound is loose due to early termination of DFS traversals (see Section~\ref{sec:evaluation} for an empirical evaluation).
Asymptotically and in terms of queries, \mkpsiattack{} is less efficient than the attacks in the next section.
Its advantage is that it only requires querying subsets of the target set, under comparatively weak assumptions.

Even when the number of protocol invocations is restricted, partial intersection recovery remains feasible; see Appendix~\ref{ap:evaluation} for empirical results.


% \begin{figure}
% 	\centering
% 	\input{chapters/figures/mkpsi_termination_example.tex}
% 	\caption{Path traversal termination example for \mkpsiattack{} and $\mkpsiattack^*$.
% 	The table on the left shows a victim set \setV. 
% 	The other tables show two subsets $\setT^{'}$ and $\setT^{''}$ of some target set.
% 	The numbers in brackets indicate the multiplicity of the corresponding identifier in \setV.
% 	$\setT'$ allows \mkpsiattack{} to terminate its current path traversal, 
% 	since all identifiers in the first column and none of the identifiers in the second column are matched.
% 	$\mkpsiattack^*$ cannot terminate, since the multiplicity of $\id_6$ does not match that of $\id_1$ and $\id_4$.
% 	$\setT^{''}$ lacks the last record of $\setT^{'}$ and, thus, also allows $\mkpsiattack^*$ to abort the path traversal. }
% 	\label{fig:mkpsi_early_termination_exmp}
% \end{figure}
