\section{Maximum Set Reconstruction with $\calF_{\LMKPM}$}\label{sec:lmkpm-attacks}

In this section, we describe three powerful attacks that exploit the ``leaky'' functionality $\calF_{\LMKPM}$. Buddhavarapu et al.~\cite{MKPMC} acknowledge this leakage but deem it acceptable as an aggregate metric that would only raise concerns across multiple executions. In contrast, we present three attacks that achieve \emph{maximum set reconstruction} (Definition~\ref{def:max_recons}) with a single protocol invocation.

We first present a baseline attack that is highly efficient but relies on a strong assumption on the protocol inputs. We then describe two additional attacks that progressively relax these assumptions.
% All three attacks preprocess the target set $T$ so that the resulting records are uniquely identifiable from the protocol output in a single invocation. This allows the adversary to map hidden identifiers revealed by the leakage back to their plaintext values. 


\subsection{The Baseline Attack}
\label{sec:baseline-attack}

We first observe that record matching is trivial when the adversary’s input set contains one record. Exploiting this, we present \baselineattack{}, which flattens the target set $T$ into an input $X$ consisting of a single record that contains all values in $\Ispace[T]$.

Recall that while the records in the input $X$ are hidden and shuffled, the order of values \emph{within} each record is preserved to support prioritized matching.
The baseline attack constructs a dictionary $\Dict$ that maps hidden values appearing in the leakage $\hXone = \{\hbx\}$ back to their original plaintext values in the input $X = \{\bx\}$. Specifically, for all $j = 0, \dots, |\hbx|$, the adversary sets
\[
    \Dict : \hbx[j] \mapsto \bx[j].
\]
It then uses $\Dict$ to recover plaintext values in the recovery set $\hYone$. It initializes an empty multiset $R_Y$, and for each hidden record $\hby_i \in \hYone$ it initializes an empty record $\bs_i$. For all $j = 0, \dots, |\hby_i|$, it checks whether $\hby_i[j] \in \Dict$; if so, it appends $\Dict[\hby_i[j]]$ to $\bs_i$. Finally, it adds $\bs_i$ to $R_Y$. In this way, the adversary recovers the plaintexts of all values in $Y$ that are in common with those in $T$.
This procedure yields a maximum set reconstruction $R_Y$ of $Y$ with respect to $T$.

We omit a full proof of correctness. Correctness of the attack directly follows from the fact that all values in the flattened target record are uniquely identifiable in a single invocation of $\calF_{\LMKPM}$.


\heading{Time and query complexity.}
Let $\ell_{\rec}$ denote the maximum record length in $T$ and $Y$, and let $n = |T|$ and $m = |Y|$.
The attack has an asymptotic time complexity of
$\bigO{\ell_{\rec}(n + m)}$.
%The membership check can be reduced to constant time by maintaining an auxiliary set of already added identifiers, as set membership can be tested in constant time.
The attack requires only one protocol invocation and therefore establishes a tight lower bound on the number of queries needed to achieve MSR (Definition~\ref{def:max_recons}).

% \begin{figure*}
% 	\input{pseudocode/recenum-code.tex}
% 	\caption{Record enumeration attack $\recenumattack$ with oracle access to the extended MK-PrivateID functionality $\calF_{LMKPM}(\cdot; Y)$. 
% 	Note that $Y$ is part of the oracle and not known to the adversary.}\label{fig:rec_enum_attack}\label{fig:idx_to_seq}\label{fig:seq_to_idx}\label{fig:dict_infer}
% \end{figure*}

\begin{figure}[t]
    \centering
    \def\rowspace{-.4pt}
    \def\minwidthemail{2.5cm}
    \def\minwidthphone{2.5cm}
    \def\minwidthid{.6cm}
    \def\linecorr{-.4pt}
    \def\blockminheight{1.4em}
    \definecolor{added-id}{HTML}{15b01a}
    \definecolor{matched-light}{HTML}{DCEDC8}
    \definecolor{matched-dark}{HTML}{C4E1A3}
    \definecolor{tiebreaker}{HTML}{A3CEE1}
    \definecolor{highlight-blue}{HTML}{4A90E2} 
    % Subfigures
    \subfloat[Target set $T$ (boxed in blue) and input set $X$ (the entire table).\label{subfig:recenum_example_plain}]{
        \resizebox{1\columnwidth}{!}{%
        \input{figures/recenum_example_plain.tex}
        }
    }
    \quad
    \subfloat[The hidden, shuffled leakage $\hXone$.\label{subfig:recenum_example_leakage}]{
        \resizebox{0.48\columnwidth}{!}{%
        \input{figures/recenum_example_leakage.tex}
        }
    }
    \caption{
    An example of a target set transformation by \recenumattack.
    (\ref{subfig:recenum_example_plain}) shows the target set $T$ (blue box) and the input set $X$, extended with prepended encoding (green box). 
    Note the second value $v_2$ in the last record.
    (\ref{subfig:recenum_example_leakage}) shows the corresponding hidden, shuffled records $\hXone$.
    The hidden values corresponding to $(v_0,v_0)$ are highlighted in green, and that corresponding to $v_2$ is highlighted in blue.
    }
    \label{fig:recenum_example}
\end{figure}

\subsubsection{A First Optimization}
The baseline attack relies on an atypical input structure---one very long record---which is both unnatural and easy to detect in practice. This motivates more refined attacks that achieve MSR without such conspicuous inputs.

A first optimization avoids arbitrarily long records by exploiting that record lengths are preserved in the leakage. The values in $\Ispace[T]$ can be partitioned into multiple records, each of a \emph{unique} length. Let $X'$ denote the resulting set of records and ${\hXone}'$ the corresponding leakage. Since each record has a distinct length and the order of identifiers within records is preserved, the adversary can uniquely match each record in ${\hXone}'$ to the plaintext record of equal length in $X'$, build a dictionary as before, and again achieve MSR.

\heading{Time and Query Complexity.}
This optimized attack still uses a single protocol query and has time complexity \bigO{\ell_{\rec}(n + m)}. The maximum record length decreases from $|\Ispace[T]|$ to approximately $\sqrt{2|\Ispace[T]|}$. While less conspicuous than the single-record variant, it remains easily detectable. Our next two attacks remove this assumption.



% \begin{figure*}[ht!]
%     \centering
%     \vspace{0pt}
% 	\input{pseudocode/snake-code.tex}
%     \caption{Snake attack with oracle access to the extended MKPM functionality $\calF_{\LMKPM}(\cdot, Y)$. $Y$ is part of the oracle and unknown to the adversary.\label{fig:snakeattack}\label{fig:snakeencode1}\label{fig:snakedecode1}} 
% \end{figure*}


\subsection{Record Enumeration Attack}\label{sec:rec_enum_attack}

We now present an attack whose input set consists of equal-length records. For simplicity, we assume that every record in the target set $T$ has the same length; the attack extends directly to target sets with records of varying lengths.

We refer to this attack as the \emph{Record Enumeration Attack}. It relies only on two properties of the functionality $\calF_{\LMKPM}$: (i) the order of values within each record of $\tP_1$'s input is preserved in the corresponding hidden records in the leakage, and (ii) values are hidden deterministically, so that repeated occurrences of the same value yield the same hidden value within a single protocol execution.
The attack proceeds by enumerating the records in $T$ and prepending to each record an encoding of its index using known values. If this enumeration can be recovered from the leakage, then the adversary can compute a dictionary $\Dict$ from hidden to plaintext values and subsequently use $\Dict$ to output a maximum set reconstruction of the victim’s input $Y$.

Without loss of generality, assume that $|T|$ is not a power of two, and let $v_0, v_1 \in \Ispace[]$ be two distinct values. Fix an ordering $(\bt_0,\ldots,\bt_{n-1})$ of the records in $T$, where $\bt_i$ denotes the $i$-th record. Each index $i \in [0,n-1]$ is encoded as a binary string of length $\lenc := \lceil \log_2 n\rceil$, where bits $0$ and $1$ are represented by $v_0$ and $v_1$, respectively. This binary encoding is prepended to $\bt_i$, and we denote by $X$ the resulting set of extended records. For example, if $n = 5$, then $\lceil \log_2 5 \rceil = 3$, and the first record $\bt_0$ is augmented as $v_0 \| v_0 \| v_0 \| \bt_0$ and added to $X$.

% See Figure~\ref{subfig:recenum_example_plain} for a small example. The encoding procedure \IdxToSeq{} is given in Figure~\ref{fig:idx_to_seq}.

We now analyze the output to $\tP_1$ when $\calF_{\LMKPM}(\ \cdot\ ; Y)$ is invoked on the augmented set of records $X$. Recall that $\calF_{\LMKPM}$ hides values via an injective random function $f_X$ while preserving the order of values within each record of $X$. Consequently, for any $\hbx \in \hXone$, the first $\lenc$ hidden values correspond to the encoded prefix and therefore comprise only two hidden values i.e., $e$ and $e'$. Moreover, we must have either $e = f_X(v_0)$ and $e' = f_X(v_1)$, or $e = f_X(v_1)$ and $e' = f_X(v_0)$.


By distinguishing between these two cases, the adversary can recover the index encoded in the prefix of each $\hbx \in \hXone$ and establish a correspondence between the hidden records in $\hXone$ and the plaintext records in $X$. To determine whether a hidden value $e$ corresponds to $v_0$ or $v_1$, observe that since $n$ is not a power of two and $|T| < 2^{\lenc}$, no record is assigned index $2^{\lenc} - 1$, and the corresponding encoding $(v_1,\ldots,v_1)$ is not used. This serves as a tiebreaker: the encoding of index $0$ is the only encoding composed of a single value, namely $(v_0,\ldots,v_0)$.

Without loss of generality, suppose that $e = f_X(v_0)$. The decoding procedure first identifies the hidden record in $\hXone$ whose first $\lenc$ values are all equal; denote this record by $\hbx_0$. Since values are not permuted within records, we must have $\hbx_0[0] = f_X(v_0) = e$. As before, the adversary can now compute a dictionary that maps hidden values to plaintext values. It initializes an empty dictionary $\Dict$.
Then using the encoded prefix of each $\hbx \in \hXone$, the adversary recovers the corresponding index $i \in [0,n-1]$. For each $\hbx \in \hXone$ and each $j = 0,\dots,|\hbx|-1$, it sets
\[
  \Dict : \hbx[j] \mapsto \bx_i[j],
\]
where $\bx_i$ is the record in $X$ with index $i$. As before, this dictionary, together with $\hYone$, can be used to compute a maximum set reconstruction $R_Y$.

%%%%%%%%%%%%%

The assumption that $n$ is not a power of two can be dropped. The adversary can introduce a third tie-breaking identifier $\id_2 \notin \{\id_0,\id_1\}$ and modify the encoding of the index $2^\ell - 1$ by replacing the last symbol in $(\id_1,\ldots,\id_1)$ with $\id_2$. This guarantees a unique, identifiable prefix and removes the ambiguity between the encodings of $0$ and $2^\ell - 1$. We adopt this approach in our full attack.
An example of a target set and its augmented input is shown in Figure~\ref{subfig:recenum_example_plain}. Its resulting leakage is shown in Figure~\ref{subfig:recenum_example_leakage}. 

The pseudocode of $\recenumattack$ is given in Figure~\ref{fig:rec_enum_attack}.


\begin{theorem}\label{thm:recenumattack:correctness}
	Let $T$ be the adversary's target set and $Y$ be the victim's input.
    $\recenumattack^{\calF_\LMKPM(\cdot, Y)}(T)$ (Figure~\ref{fig:rec_enum_attack}) achieves maximum set reconstruction of $Y$ with respect to $T$ (Def.~\ref{def:max_recons}).
\end{theorem}

The proof of Theorem~\ref{thm:recenumattack:correctness} can be found in Appendix~\ref{sec:recenumattack:correctness}.


\heading{Time and query complexity.}
Assuming that the binary encoding can be computed in time $\bigO{\log n}$, then computing the augmented input set takes $\bigO{n \log n}$.
Identifying $\hbx_0$ also incurs time $\bigO{n \log n}$. Constructing the dictionary $\Dict$ takes time $\bigO{n(\log n + \ell_{rec})}$, while computing $R_Y$ using $\Dict$ and $\hYone$ requires time $\bigO{\ell_{\rec} m}$.

Overall, the attack runs in time \bigO{n \log n + \ell_{\rec}(n+m)} and requires only a single query.

% \textbf{Discussion.}
% Compared to the baseline attack, the records are now much shorter and are of uniform length.
% Specifically, records are now of length $\lceil \log_2 n\rceil + \lambda$,
% where $\lambda$ denotes the original record length in the target set.
% Ignoring the constant $\lambda$, this is an exponential reduction from the maximum record lengths 
% $|\Ispace{\setT}|$ and $\approx \sqrt{2|\Ispace{\setT}|}$
% for the baseline attack and its first optimization respectively.
% At the same time, \recenumattack{} makes considerably weaker assumptions on the set of admissible inputs, thus,
% resulting in a clear improvement.



\subsection{Snake Attack}\label{sec:snake_attack}

\begin{figure}
	\centering
	{\def\rowspace{.4cm}
	\def\minwidthemail{2cm}
	\def\minwidthphone{2.1cm}
	\def\minwidthid{.6cm}
	\def\linecorr{-.4pt}
	\def\blockminheight{1.3em}
	\definecolor{added-id}{HTML}{15b01a}
    \subfloat[\label{subfig:snake_example_unique}]{
        \resizebox{0.85\columnwidth}{!}{%
        \input{figures/snake_encode1_example.tex}
        }
    }
    \quad
	\subfloat[\label{subfig:snake_example_general}]{
        \resizebox{0.85\columnwidth}{!}{%
        \input{figures/snake_encode2_example.tex}
        }
    }
	}
	\caption{Results of preprocessing a set of records \textbf{(\ref{subfig:snake_example_unique})} if there is a column that only contains unique identifiers 
	and \textbf{(\ref{subfig:snake_example_general})} if an artificial unique column needs to be added.
	The original records have black borders. Added identifiers are highlighted in green. Arrows indicate the (implicit) linked list.}\label{fig:snake_exmp}
\end{figure}


While the record enumeration attack improves over the baseline in terms of detectability, it still requires an input whose record lengths grow with the target set size. We address this limitation by imposing an order on the records without explicitly assigning a unique index to each one. This approach extends each record by only two identifiers.

The attack starts by checking whether there exists a column $j^*$ in $T$ in which every identifier is unique, i.e., $|\{\bt[j^*] \setdsc \bt \in T\}| = |T|$.
This is a reasonable assumption since many identifiers such as email addresses are usually unique across users.
If no such column exists, the adversary can create one by sampling $n$ distinct identifiers
and prepending each identifier to a distinct  record in $T$ (in this case $j^* = 0$).

We can then link the records of $T$ by first choosing some arbitrary ordering $T= \{\bt_0, \dots, \bt_{n-1}\}$ and appending the unique index of the $i+1$-th record to the $i$-th record for all $i \in [n-1]$.
See Figure~\ref{subfig:snake_example_unique} for a small example. The linking procedure \snakeencodeUnique{} outputs the modified target set $X$ as a list $(\bx_0, \dots, \bx_{n-1})$, such that $\bt_i$ corresponds to $\bx_i$ in the (implicit) linked list.

Since the identifier hiding function in $\calF_\LMKPM$ is injective and deterministic for repeating identifiers, the pointers are preserved in the leakage $\hXone$.
The adversary can therefore find the start of the linked list by finding the (unique) record whose $j^*$-th identifier is not appended to any other record and traverse the linked list to recover the original ordering of $X$.


The procedure \snakerecoverUnique{} takes the input set leakage $\hXone$ and $j^*$ and outputs the elements of $\hXone$ as a list $(\bs_0, \dots, \bs_{n-1})$ such that $\bs_i$ has index $i$ in the linked list. Once the hidden records in $\hXone$ are matched with the corresponding plaintext records in $X$, we can apply a substitution-based transformation to recover a maximum reconstruction from $\hYone$.

The pseudocode for the full attack are given in Figure~\ref{fig:snakeattack}.



\begin{theorem}\label{thm:snakeattack:correctness}
	Let $T$ be the adversary's target set and $Y$ be the victim's input.
    $\snakeattack^{\calF_\LMKPM(\cdot, Y)}(T)$ (Figure~\ref{fig:rec_enum_attack}) produces a maximum reconstruction of $Y$ with respect to $T$ (Def.~\ref{def:max_recons}).
\end{theorem}

The proof of Theorem~\ref{thm:snakeattack:correctness} can be found in Appendix~\ref{sec:snakeattack:correctness}.

\heading{Time and query complexity.} 
Assuming \id{} in line \ref{lin:snake_encode_last_id} can be located in constant time, \snakeencodeUnique{} has an average-case time complexity of \(\bigO{n}\) for \(n = |T|\). The same applies to \snakerecoverUnique. Finding the starting index in line \ref{lin:snake_recover_c} involves inserting the last identifier of each record into a dictionary and checking for the presence of the \(j^*\)-th identifier, while the loop in lines \ref{lin:snake_recover_dowhile}--\ref{lin:snake_recover_dowhile_end} performs \(n\) iterations, traversing the linked list once.

Let \(\ell_{\rec}\) denote the length of the largest record in either \(T\) or \(Y\). Determining whether a column in \(T\) contains only unique identifiers can be done in $\bigO{\ell_{\rec} n}$ time, assuming that dictionary operations are average-case constant time. Constructing the dictionary $\Dict$ involves up to \(\ell_{\rec} n\) writes. Factoring in \dictInfer's \(\bigO{\ell_{\rec} m}\) complexity with \(m = |Y|\), the overall average-case time complexity for \snakeattack{} is \(\bigO{\ell_{\rec} (n + m)}\). Similar to the previous attacks, \snakeattack{} requires only one protocol invocation.

% \heading{Discussion and mitigation.}
% While requiring the same number of protocol invocations and incurring a comparable computational complexity to the other attacks, \snakeattack{} stands out for requiring only minimal modifications to the target set and is applicable to scenarios where the record length is constrained to a small constant.
% Meta's Private Computation Solution \cite{FBPCSRepo} serves as a concrete example, where records are limited to at most four identifiers. If the target set already meets the maximum allowed record length, the adversary can always rearrange the target set into shorter records and use the available space for the snake encoding.

% Since records are only extended by a small constant, limiting record lengths to mitigate against attacks, 
% as proposed previously, is ineffective.
% However, the chain-like structure of the modified target set, which enables recovering the original order of the identifiers,
% allows the victim to detect and mitigate the attack.
% To capture a broader variety of such linking strategies than just the approach we presented above, 
% we consider a graph $\graph(\setX) = (\vertSet_\setX, \edgeSet_\setX)$ for some set of records \setX{}, which contains one vertex for every record of the target set 
% and an edge between every pair of vertices whose corresponding records contain at least one common identifier.
% \begin{equation*}
% 	\vertSet_\setX := \{v_x \setdsc x \in \setX \}
% \end{equation*}
% \begin{equation*}
% 	\edgeSet_\setX := \{(v_x, v_{x'}) \setdsc \exists i, j. x[i] = x'[j] \}
% \end{equation*}
% As depicted in \cref{fig:snake_exmp}, the graph $\graph(\setT')$, which is generated from the modified target set $\setT'$ produced by \snakeencodeUnique{},
% only has a single connected component. 
% Furthermore, since the victims protocol leakage $\leak^P_{\setT'}$ (see \cref{fig:MKPM}) simply contains a shuffled and renamed copy of $\setT'$,
% $\graph(\setT')$ and $\graph(\leak^P_{\setT'})$ are isomorphic and thus have the same number of connected components. 
% The victim can therefore detect such linkage-based attack strategies and abort the protocol execution.
% This also defends against the record enumeration attack presented in the last section.
% However, one needs to be careful not to accidentally reject valid inputs, 
% as large connected components may occur naturally.
% The example of IP addresses behind a NAT device we mentioned in the last section also applies here.
