\section{Preliminaries}
\heading{Notation.} For $n \in \NN$, we define $[n] := \{1, \dots, n\}$.  For
any $\ell, n\in \NN$ such that $\ell \geq \lfloor \log_2 (n+1)\rfloor$,
$\Bin{\ell}(n) \in \{0,1\}^\ell$ denotes the $\ell$-bit binary representation of
$N$.

For sets $X,Y$ and any function $f:X\to Y$, we denote the image of $X$ under $f$
as $f(X) := \{f(x) | x \in X\} \subseteq Y$.  Moreover, $\Funcs[X, Y]$ denotes
the space of functions $f: X \to Y$ and $\InjFuncs[X, Y] \subset \Funcs[X, Y]$
denotes the set of injective functions $f: X \to Y$.  $\Perms[X]$ denotes the
set of all permutations of $X$.

\subsection{Multi-key Private Matching Functionality}
\label{sec:MKPM-functionality}
\heading{Indexed records.} The Multi-Key PrivateID (MK-PrivateID)
protocol~\cite{MKPMC} extends the single-key PrivateID protocol~\cite{PMC} to
support matching on multiple keys (e.g., names or email addresses). We use terms
\emph{identifiers} and \emph{keys} interchangeably, following the terminology of
the original paper \cite{MKPMC}. Each record contains multiple indexed values
under different keys (See Section~\ref{sec:mkpmc_functionality} for the
representation). The keys themselves are implicit.

\heading{Matching procedure.} We refer to the functionality implemented by
MK-PrivateID as the \emph{Multi-key Private Matching (MKPM)} functionality. In
this setting, two parties $P_1$ and $P_2$ hold sets of records $X$ and $Y$,
respectively. MKPM first groups records that share at least one common indexed
value, and then applies a tailored matching procedure to produce a one-to-one
correspondence between the two sets. This design is motivated by the use case in
which partially duplicated records correspond to the same individual, and a
one-to-one mapping suffices for downstream data analysis.

During matching, one-to-many and many-to-one relationships may arise (i.e., when
a record from one party shares indexed values with multiple records from the
other.). The protocol resolves many-to-one matches using a ranked, deterministic
join logic, and resolves one-to-many matches randomly.

To enable downstream computation over the associated data, the protocol
introduces \emph{universal identifiers (UIDs)} to label joined records. It
outputs to each party a mapping from UIDs to its records such that matched
records are assigned the same UID, while unmatched records receive distinct
UIDs.

Figure~\ref{fig:matching-logic-example} illustrates this process. It shows an
example input featuring a one-to-many match (Fig.~\ref{fig:match-input}) that is
resolved into a one-to-one correspondence, along with the resulting output
(Fig.~\ref{fig:match-output}).

\heading{Security guarantee.} The original work~\cite{MKPMC} sketches a proof
for semi-honest security. However, we note that the specified functionality
leaks more information than the intended output. We therefore distinguish the
intended functionality, which computes the set of UIDs and the mapping of UIDs
to records ($\calF_{\MKPM{}}$), from the real functionality
($\calF_{\LMKPM{}}$), which reveals additional information. Returning to our
example, given the tables in Figure~\ref{fig:match-input}, $\calF_{\MKPM{}}$
outputs only the maps and UID sets shown in Figure~\ref{fig:match-output},
whereas $\calF_{\LMKPM{}}$ additionally leaks to party $P_1$ a graph isomorphic
to that comprising the green and red edges in Figure~\ref{fig:match-input}.

\subsubsection{Functionality}
\label{sec:mkpmc_functionality}
We now present a formal description of the functionality $\calF_{\MKPM{}}$. Let
$\Ispace$ denote the universe of record values

Party $P_1$ holds
\[
  X:= \{\bx_i = (x_{i,1}, \ldots, x_{i,j}, \ldots, x_{i, n_i}) \mid j \in
  [n_i]\}
\]
of size $n$,
and party $P_2$ holds
\[
  Y := \{\by_k = (y_{k,1}, \ldots, y_{k,\ell}, \ldots, y_{k, m_k}) \mid \ell \in
  [m_k]\}
\] of size $m$. Here, we slightly abuse notation, using $n_i, m_k $ to denote
the lengths of records $\bx_i$ and $\by_k$, respectively, for all $i \in [n]$
and all $k \in [m]$; all values $x_{i,j}$ and $y_{k,\ell}$ lie in $\Ispace$.

%% Since the positional leakage is not entirely eliminated, we augment the
%% functionality explicitly specifies operation performed and the leakage profile.

To suppress leakage arising from positional information in the matching
protocol, the original work \cite{MKPMC} introduces random
permutations. Specifically, the records in $X$ are permuted while preserving the
order of indexed values within each record, whereas in $Y$ both the records and
the values within each record are permuted. We denote the resulting collections
by $X'$ and $Y'$, respectively.\footnote{Although sets are unordered, the
  implementation~\cite{PIDRepo} treats inputs as ordered lists of records; we
  follow the authors of~\cite{MKPMC} in adopting this terminology.}

The core of the protocol is the $\match$ procedure (see Appendix~\ref{ap:mkpc}
for detailed pseudocode), which outputs a one-to-one correspondence between the
two sets. It takes as input the shuffled inputs $X'$ and $Y'$. Each record in
$X'$ (resp. $Y'$) is matched with at most one record in $Y'$ (resp. $X'$). Both
parties receive a common set of universal identifiers, along with a mapping from
each UID to their local records or $\bot$ for unmatched records.

The intuition behind $\match$ is to process indexed values in an order chosen by
Party $P_1$, allowing it to prioritize values that are less likely to
change. For example, matching on a social security number typically yields
higher-quality results than matching on a phone number, which is more likely to
change.

More formally, for each identifier position $j$ in $X'$, the $\match$ procedure
scans all $\by_k \in y'$ and matches $\by_k$ to the first $\bx_i \in X'$ whose
$j$-th value appears in $\by_k$, that is, for which there exists an $\ell$ such
that
\[
  \by_k[\ell] = \bx_i[j],
\]
where $i$ is minimal.

A detailed description of $\calF_{\MKPM}$ is provided in Figure~\ref{fig:MKPM}.

\begin{figure}
  \fbox{%
    \begin{minipage}[t]{0.98\columnwidth}
      \textbf{Parameters:} Two parties, $P_1$ and $P_2$, set sizes $n, m\in \NN$
      and
      record lengths $n_i, m_k \in \NN$ for $i\in[n]$ and $k\in[m]$.\\
      \textbf{Functionality} $\calF_{\MKPM}(X; Y)$ \dbox{$\calF_{\LMKPM}(X; Y)$}~: 
      %%% 
      \begin{enumerate}
      \item Receive the input from party $P_1$:
        $X = \{\bx_i \setdsc i \in [n]\}$
      \item Receive the input from party $P_2$:
        $Y = \{\by_k \setdsc k \in [m]\}$
      \item Sample $\pi_X \sample \Perms[[n]]$ and $\pi_Y \sample \Perms[[m]]$
      \item Let $X' := \{\bx'_i \setdsc i \in [n]\}$, where $\bx'_i := \bx_{\pi_X(i)}$
      \item Let $Y' := \{\by'_k \setdsc k \in [m]\}$, where $\by'_k :=
        \by_{\pi_Y(k)}$
      \item Shuffle the values in $\by'_k$ for all $k \in [m]$
      \item Compute set $\UID$, mappings $\MX, \MY$ $\gets \match(X', Y')$ (See
        Figure \ref{fig:match_logic} in Appendix~\ref{ap:mkpc}.)
      \end{enumerate}
      \begin{adjustbox}{minipage=0.98\textwidth,precode=\dbox}
        \begin{enumerate}
          \addtocounter{enumi}{7}
        \item  Sample $f_1, f_2 \sample \InjFuncs[\Ispace,\; \Uspace]$
        \item  $\hXone := \{(f_1(\bx'_i[1]), \dots, f_1(\bx'_i[n_i])) \setdsc i
          \in [n]\}$.
        \item  $\hYone := \{(f_1(\by'_k[1]), \dots, f_1(\by'_k[m_k])) \setdsc k
          \in [m]\}$.
        \item  $\pi \sample \Perms[[n]]$.
        \item  $X'' := \{\bx''_i \setdsc i \in [n]\}$, where $\bx''_i :=
          \bx_{\pi(i)}$.
        \item  $\hXtwo := \{(f_2(\bx''_i[1]), \dots, f_2(\bx''_i[n_i])) \setdsc i \in [n]\}$.
        \item $\leak^1 \gets (\hXone,\hYone)$,\ \  $\leak^2 \gets \hXtwo$
        \end{enumerate}
      \end{adjustbox}
      \begin{enumerate}
        \addtocounter{enumi}{14}
      \item Output:\hfill
        \begin{itemize}[label=-]
        \item Send $\UID, \MX$ \dbox{$,\leak^1$} to $P_1$.
        \item Send $\UID, \MY$ \dbox{$,\leak^2$} to $P_2$.
        \end{itemize}
      \end{enumerate}
    \end{minipage}
  }
  \caption{The Multi-Key Private Matching functionality $\calF_{\MKPM}(X;
    Y)$. The additional steps of the leakage-aware functionality
    $\calF_{\LMKPM}(X; Y)$ are shown in \protect\dbox{dashed boxes}.}
  \label{fig:MKPM}
\end{figure}

\begin{figure*}[t]
  \centering
  \def\rowspace{-.4pt}
  \def\minwidthemail{2.1cm}
  \def\minwidthphone{2.1cm}
  \def\minwidthid{.5cm}
  \def\minwidthuid{.8cm}
  \def\linecorr{-.4pt}
  \def\blockminheight{1.3em}
  \definecolor{added-id}{HTML}{15b01a}
  \definecolor{matched-light}{HTML}{DCEDC8}
  \definecolor{matched-dark}{HTML}{C4E1A3}
  \definecolor{tiebreaker}{HTML}{A3CEE1}
  \definecolor{highlight-blue}{HTML}{4A90E2} 
  % Subfigures
  \subfloat[\label{fig:match-input}The inputs from Parties $P_1$ (left) and $P_2$ (right).]{
    \resizebox{1.335\columnwidth}{!}{%
      \input{figures/match-input.tex}
    }
  }
  \subfloat[\label{fig:match-output}The outputs to Parties $P_1$ (left) and $P_2$ (right).]{
    \resizebox{0.76\columnwidth}{!}{%
      \input{figures/match-output.tex}
    }
  }
  \caption{In (a), we illustrate a one-to-many match: party $P_1$’s record
    $\bx_0$ matches party $P_2$’s records $\by_0$ on email and $\by_1$ on phone
    (red edges). The conflict is resolved randomly, yielding a one-to-one
    mapping in which $\bx_0$ and $\by_0$ are assigned the same UID (2093), while
    $\by_1$ is assigned a distinct UID (9349). Record $\bx_1$ matches only
    $\by_2$ on email (blue edge) and thus both are assigned UID 3042. Both
    parties learn their local mappings and the universe of UIDs.
    \label{fig:matching-logic-example}}
\end{figure*}

\subsubsection{Leakage.}
\label{sec:leakage}
In favour of higher efficiency, MK-PrivateID leaks additional information. We
capture this leakage using an extended ``leaky'' functionality, denoted by
$\calF_{\LMKPM{}}$. The leakage differs for $P_1$ and $P_2$, and we describe
each separately.

To model this leakage, we introduce a \emph{hiding function}, which is an
injective random function from the value space to the UID space,
$f_1:\Ispace\to\Uspace$. This function assigns UIDs to values and allows us to
formalize the relationships between records that can be inferred from the output
UIDs. By applying the hiding function to the shuffled sets $X'$ and $Y'$, we
obtain \emph{hidden copies} of these sets, which are available to party $P_1$.

This leakage can alternatively be interpreted as a \emph{bipartite graph}
$G = (V_{X'} \cup V_{Y'}, E)$, where $V_{X'}, V_{Y'}$ correspond to the records
in $X'$ and $Y'$, respectively. An edge $(\bx_i', \by_k') \in E$ exists if and
only if the records $\bx_i' \in X'$ and $\by_k' \in Y'$ share at least one
indexed value.

Note that because the order of indexed values within each record of $X'$ is
preserved, the matching process induces a priority ordering over edges. This
ordering is determined by the position of shared values within the records of
$X'$.

Although $\match$ computes only a partial matching in $G$, such that each vertex
is matched to at most one vertex in the other vertex set, party $P_1$ still
learns the entire graph $G$.

The leakage observed by $P_2$ is more limited. Party $P_2$ learns only a hidden
and re-shuffled copy of $X$. Specifically, the records of $X$ are re-shuffled
using fresh randomness, yielding a set $X''$. A new hiding function
$f_2 : \Ispace \to \Uspace$ is then sampled and applied to all values in $X''$,
and the resulting hidden set is available to $P_2$.

The pseudocode can be found in Figure~\ref{fig:MKPM}, where the additional
leakage is shown dashed boxes.
