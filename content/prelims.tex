\section{Preliminaries}


\subsection{The MK-PrivateID Functionality}
\label{sec:MK-PID}

The Multi-Key PrivateID (MK-PrivateID) protocol~\cite{MKPMC} extends the single-key PrivateID protocol~\cite{PMC} to support matching on multiple identifiers. In this setting, two parties $P_1$ and $P_2$ hold tables of records $X$ and $Y$, respectively, where each record contains multiple identifiers (e.g., names or email addresses). The matching process produces a one-to-one correspondence between records in $X$ and $Y$ such that each matched pair shares at least one identifier.

MK-PrivateID’s strength lies in handling one-to-many and many-to-one matches i.e., when a record from one party shares identifiers with multiple records from the other. The protocol resolves many-to-one matches using a ranked, deterministic join, and resolves one-to-many matches randomly. Each party outputs a mapping of universal identifiers (UIDs) to their records such that matching records are assigned the same UID, while unmatched records receive distinct UIDs. These UIDs enable further downstream computation over the associated data. Figure~\ref{fig:matching-logic-example} illustrates an example input featuring a one-to-many match (Fig.~\ref{fig:match-input}) that is resolved to a one-to-one correspondence, along with the resulting output (Fig.~\ref{fig:match-output}).

The original work~\cite{MKPMC} provides a proof sketch for security against a semi-honest adversary, along with a functionality description. We note that the specified functionality leaks more information than desired ouput. We therefore distinguish the intended functionality---which computes the set of UIDs and the mapping of UIDs to records ($\calF_{\MKPM{}}$)---from the real functionality ($\calF_{\LMKPM{}}$), which additionally leaks the entire bipartite graph of all matches. Returning to our example, given the tables in Figure~\ref{fig:match-input}, $\calF_{\MKPM{}}$ outputs only the maps and UID sets shown in Figure~\ref{fig:match-output}, whereas $\calF_{\LMKPM{}}$ additionally leaks to party $P_1$ a graph isomorphic to that comprising the green and red edges in Figure~\ref{fig:match-input}.

\subsubsection{Functionality}
\label{sec:mkpmc_functionality}
We start by presenting a formal description of the intended functionality $\calF_{\MKPM{}}$. Let $\calI$ denote the universe of identifiers (e.g., email addresses, phone numbers, IP addresses), and let $\lambda \in \NN$ be the maximum number of identifiers per record. Party $P_1$ holds
\[
X:= \{\bx_i = (x_{i,1}, \ldots, x_{i,n_i}) \mid i \in [n]\},
\]
and party $P_2$ holds
\[
Y := \{\by_k = (y_{k,1}, \ldots, y_{k,m_k}) \mid k \in [m]\},
\]
where all identifiers $x_{i,j}$ and $y_{k,\ell}$ are in $\calI$.

The functionality takes $X$ and 
$Y$ as inputs from the respective parties and then applies a random permutation. The records of $X$ are permuted while preserving the order of identifiers within each record, whereas in $Y$ both the records and the identifiers within each record are permuted. We denote the resulting collections by $X'$ and $Y'$, respectively.\footnote{Although sets are unordered, the implementation~\cite{PIDRepo} treats inputs as ordered lists of records; we follow the authors of~\cite{MKPMC} in adopting this terminology.}

The core of the protocol is the record-matching procedure $\match$ (see Appendix~\ref{ap:mkpc} for detailed pseudocode), which takes shuffled inputs $X'$ and $Y'$. Each record in $X'$ (resp. $Y'$) is matched with at most one record in $Y'$ (resp. $X'$). For each identifier position $j$ in $X'$, $\match$ scans all $\by_k \in y'$ and matches $\by_k$ to the first $\bx_i \in X'$ whose $j$-th identifier appears in $\by_k$ i.e., for which there exists $\ell$ such that
\[
\by_k[\ell] = \bx_i[j],
\]
where $i$ is minimal. By processing identifiers in this order, Party $P_1$ can prioritize matching on identifiers that are less likely to change. For example, matching on a social security number yields higher-quality results than matching on a phone number, which is more likely to change.

The matching logic assigns a unique identifier from a space $\calG$ to every pair of matched records, as well as to each unmatched record in $X$ and $Y$; we denote the resulting set of identifiers by $\UID$. The procedure also constructs two maps, $M_X: \UID \to X\cup \{\bot\}$ and $M_Y: \UID \to Y \cup \{\bot\}$, which link each UID to its corresponding record in $X$ or $Y$, or to $\bot$ if it corresponds to an unmatched record of the other party. Party $P_1$ receives $\UID$ and $M_X$, while $P_2$ receives $\UID$ and $M_Y$. Both parties obtain a common set of universal identifiers along with a mapping from each UID to their local records or $\bot$ for unmatched records.

The detailed description of $\calF_{\MKPM}$ can be found in Figure~\ref{fig:MKPM}.

\begin{figure*}[t]
    \centering
    \subfloat[\label{fig:match-input}The inputs from Parties $P_1$ (left) and $P_2$ (right).]%
    {
    \includegraphics[clip, trim=0cm -1.25cm 0cm 0cm,width=1.3\columnwidth]{figures/match-input.pdf}} 
    %\quad
    \subfloat[\label{fig:match-output}The outputs to Parties $P_1$ (left) and $P_2$ (right).]%
    {
    \includegraphics[width=0.755\columnwidth]{figures/match-output.pdf}}
    \caption{In (a), we illustrate a one-to-many match: party $P_1$’s record $\bx_1$ matches party $P_2$’s records $\by_1$ on email and $\by_2$ on phone (red edges). The conflict is resolved randomly, yielding a one-to-one mapping in which $\bx_1$ and $\by_1$ are assigned the same UID (2093), while $\by_2$ receives a distinct UID (9349). Record $\bx_2$ matches only $\by_2$ on email (green edge) and is assigned UID 3042. Both parties learn their local mappings and the universe of UIDs.
    \label{fig:matching-logic-example}}
\end{figure*}


\begin{figure}
    \fbox{%
    \begin{minipage}[t]{0.98\columnwidth}
		\textbf{Parameters:} Two parties, $P_1$ and $P_2$, set sizes $n, m\in \NN$ and
		record lengths $n_i, m_j \in \NN$ for $i\in[n]$ and $j\in[m]$.\\
		\textbf{Functionality} $\calF_{\MKPM}(X; Y)$ \dbox{$\calF_{\LMKPM}(X; Y)$}~: 
        %%%
        \begin{enumerate}
			\item Receive the input from party $P_1$: $X = \{\bx_i \setdsc i \in [n]\}$.
			\item Receive the input from party $P_2$: $Y = \{\by_i \setdsc i \in [m]\}$.
			\item Sample $\pi_X \sample \Perms[[n]]$ and $\pi_Y \sample \Perms[[m]]$.
			\item Let $X' := \{\bx'_i \setdsc i \in [n]\}$, where $\bx'_i := \bx_{\pi_X(i)}$.
			\item Let $Y' := \{\by'_i \setdsc i \in [m]\}$, where $\by'_i := \by_{\pi_Y(i)}$.
			\item Shuffle the identifiers in $\by'_i$ for all $i \in [m]$.
			\item Compute $\UID, \MX, \MY \gets \match(X', Y')$ (Figure \ref{fig:match_logic}).
		\end{enumerate}
        \begin{adjustbox}{minipage=0.98\textwidth,precode=\dbox}
        \begin{enumerate}
				\addtocounter{enumi}{7}
				\item  $f_1, f_2 \sample \InjFuncs[\Ispace,\; \calG]$.
				\item  $\hXone := \{(f_1(\bx'_i[1]), \dots, f_1(\bx'_i[n_i])) \setdsc i \in [n]\}$.
				\item  $\hYone := \{(f_1(\by'_i[1]), \dots, f_1(\by'_i[m_i])) \setdsc i \in [m]\}$.
				\item  $\pi \sample \Perms[[n]]$.
				\item  $X'' := \{\bx''_i \setdsc i \in [n]\}$, where $\bx''_i := \bx_{\pi(i)}$.
				\item  $\hXtwo := \{(f_2(\bx''_i[1]), \dots, f_2(\bx''_i[n_i])) \setdsc i \in [n]\}$.
				\item $\leak_1 \gets (\hXone,\hYone)$,\ \  $\leak_2 \gets \hXtwo$
			\end{enumerate}
		\end{adjustbox}
			\begin{enumerate}
			\addtocounter{enumi}{13}
			\item Output:\hfill \begin{itemize}
					\item Send $\UID, \MX$ \dbox{$,\leak_1$} to $P_1$.
					\item Send $\UID, \MY$ \dbox{$,\leak_2$} to $P_2$.
			\end{itemize}
		\end{enumerate}
    \end{minipage}
    }
	\caption{The Multi-Key Private Matching functionality $\calF_{\MKPM}(X; Y)$. The additional steps of the leakage-aware functionality $\calF_{\LMKPM}(X; Y)$ are shown in \protect\dbox{dashed boxes}.
	The record-matching procedure \match{} is defined in Figure~\ref{fig:match_logic}.}
\label{fig:MKPM}
\end{figure}

\ff{edited notation up to here}
\subsubsection{Leakage.}
In favor of higher efficiency, MK-PrivateID leaks additional information which we capture with an extended ``leaky'' functionality $\calF_{\LMKPM{}}$. 
We distinguish between the leakage observed by $P_1$ and that observed by $P_2$.

The leakage to party $P_1$ consists of a renamed copy of the shuffled sets $X'$ and 
$P_2'$. Concretely, we sample an injective random function $f_1:\Ispace\to\calG$, referred to as a hiding function, and apply it to all identifiers in $X'$ and 
$Y'$. Party $P_1$ observes the resulting hidden sets.

Equivalently, the leakage to $P_1$ can be viewed as a bipartite graph $G = (V_X \cup V_Y, E)$, where $V_X$ corresponds to the records in $X'$ and $V_Y$ corresponds to the records in $Y'$. An edge $(\bx_i', \by_k') \in E$ exists if and only if the records
$\bx_i' \in X'$ and $\by_k' \in Y'$ share at least one identifier. Further note that, because the identifier order within records of $X'$ is preserved, the matching process induces a priority ordering over edges, determined by the position of shared identifiers within records of $X'$.


Although the procedure $\match$ computes only a partial matching in $G$, such that each vertex is matched to at most one
vertex in the other vertex set, party $P_1$ still learns the full graph $G$.

The leakage observed by $P_2$ consists only of a hidden copy of $X$. The records of $X$ with fresh randomness, yielding a set $X''$. Then, a new hiding function $f_2 : \Ispace \to \calG$ is sampled and used to hide the identifiers in $X''$.
$P_2$ observes the hidden and re-shuffled set $X''$.

The pseudocode can be found in Figure~\ref{fig:MKPM} with the additional leakage contained in a dashed boxed.

\subsection{Recovery Goals}
\label{sec:recovery-goals}

Throughout this work, we consider a setting with two parties, where one party (the \emph{victim}) behaves honestly and holds a fixed, static input, while the other party is \emph{input-malicious}. The malicious party follows the protocol specification but may evaluate the functionality arbitrarily many times and adaptively choose its own inputs. 
The adversary is given some target set $T$ and oracle access to $\calF(\cdot; Y)$ and tries to infer as much information about $Y$ with respect to $T$ as possible. The adversary’s precise objective depends on the targeted functionality, which we specify below.


% \begin{definition}[Intersection Recovery]
% 	Let $F$ be either the \PSU{} or the \PSUCA{} functionality and let $X$ and $Y$ be two sets.
% 	An adversary $\adv$ provided with the target set $X$ and oracle access to $F(\cdot, Y)$
% 	achieves \textbf{intersection recovery} if it outputs $X \cap Y$.
% \end{definition}

% \subsection{Intersection Recovery in the Multi-Key Setting}\label{sec:MK_IR_goals}
% Given that the MKPM functionality operates on sets of records, 
% intersection recovery as we introduced it above would entail
% recovering the set of records that appear in both input sets.
% However, in real-world scenarios, it is rather unlikely that two records match exactly
% and we can expect the intersection between the inputs in the traditional sense to be small, or even empty.
% We therefore generalize the intersection recovery attack goal to the multi-key setting,
% which results in two new attack goals.
% From now on the target and victim sets are sets of records, which we denote by \setT{} and \setV{} respectively.

% \subsubsection{Recovering Matched Records}\label{sec:MRR_goal}
% Given that the matching logic used in MK-PrivateID (see \cref{fig:match_logic}) 
% pairs records and assigns the the same uid to two matched records and separate uids to unmatched ones, 
% one can think of \match{} as computing a pseudo-union of records,
% whereby a record in the victim set and a record in the target set are considered equal 
% if they are assigned the same uid by the matching logic.
% Recovering the corresponding pseudo-intersection 
% -- the records of the attacker's target set which are matched with some record in the victim set --
% seems a natural generalization of the intersection recovery goal we introduced above.
% However, since \setT{} and \setV{} are shuffled before the matching step, 
% the matching logic does not consistently pair the same records across multiple protocol invocations with the same inputs.
% In fact, even the number of matched records may fluctuate.
% This not only makes such an attack goal hard to formalize, 
% but also greatly complicates proving the correctness of the attacks aiming to achieve said goal. 

% However, we can relax the notion of such a pseudo-intersection to
% include all records of the target set which share at least one identifier with some record in the victim set,
% that is, all records that could potentially be matched by the matching logic.
% We call these records \emph{matchable records} and the attacker's goal shall be to find 
% all matchable records its target set. We formalize this using the following notation: 
% $$\setT \sqcap \setV := \{t \in \setT \setdsc \exists v \in \setV\; \exists j, \ell \in \N : t[j] = v[\ell]\}$$
% Note that in contrast to the standard set intersection, 
% $\setT \sqcap \setV$ is not commutative.
% In particular, $\setT \sqcap \setV$ is a subset of $\setT$, but not necessarily of $\setV$.
% We use this attack goal in the context of analyzing the \MKPM{} functionality (without leakage).

% \begin{definition}[Matchable Record Recovery]\label{def:matchable_records_recovery}
% 	Let \setT{} and \setV{} be two sets of records.
% 	An adversary $\adv$ provided with the target set $\setT$ and oracle access to $\MKPM(\cdot, \setV)$
% 	achieves \textbf{Matchable Record Recovery} (MRR) if it outputs $\setT \sqcap \setV$.
% \end{definition}

% Note that MRR does not require the attacker to reconstruct any explicit identifiers or records of the victim set.
% Nevertheless, this information can be sensitive and should not be easily recoverable,
% as the mere information that at least one identifier of some user occurs in another organization's data set 
% can be detrimental to the privacy of said user. 
% We expect the authors of MK-PrivateID to share our view, 
% as they highlight specific precautions against leaking this information in their protocol design.

% \subsubsection{Recovering Matched Identifiers}\label{sec:IIR_goal}
% As elaborated above, only recovering records from the victim set that exactly match some record in the target set
% is unlikely to yield satisfactory results.
% However, this is not necessary if one does not care about whole records and simply wants to 
% determine which identifiers of the target set also occur in the victim set.
% Our second generalization of intersection recovery captures exactly this:
% the attacker shall determine the set of identifiers that occur in both the target set and the victim set.

% Recall that for any set of records \setX{}, we denote the set of identifiers that occur in \setX{} with $\Ispace{\setX}$.
% The attack goal we outlined above therefore corresponds to recovering the set $\Ispace{\setT} \cap \Ispace{\setV}$.
% This goal is achieved by our first attack that considers the additional information leaked by MK-PrivateID.
% We therefore state the its definition using the extended functionality \LMKPM{}.

% \begin{definition}[Identifier Intersection Recovery]\label{def:IR_goal}
% 	Let \setT{} and \setV{} be two sets of records.
% 	An adversary $\adv$ provided with \setT{} and oracle access to $\LMKPM(\cdot, \setV)$
% 	achieves \textbf{Identifier Intersection Recovery} (IIR) if it outputs $\Ispace{\setT} \cap \Ispace{\setV}$.
% \end{definition}

\subsubsection{Maximum Set Reconstruction}\label{sec:MR_goal}
Our strongest attack goal is to recover as much information as possible about the victim’s input, given a target set of records $T$.
Specifically, the adversary aims to reconstruct all victim records that contain at least one identifier appearing in $T$. We refer to this goal as \emph{Maximum Set Reconstruction} (MSR).
See Figure~\ref{fig:maximum-reconstruction-example} for an illustration.

\begin{definition}[Maximum Set Reconstruction]\label{def:max_recons}
	Let $T$ and $Y$ be sets of records. An adversary $\adv$, given $T$ and oracle access to the functionality $\calF_{\LMKPM}(\ \cdot\ ; Y)$, achieves \textbf{maximum set reconstruction (MSR)} of $Y$ with respect to $T$ if it outputs a multiset $R_Y$ for which there exists an injective mapping $\varphi : R_Y \to Y$ such that
	\begin{enumerate}
		\item For all $\by^* \in R_Y$ and all $\id \in \by^*$ we have $\id \in \varphi(\by^*)$.
		\item For all $\by^* \in R_Y$ 
		and all $\id \in\varphi(\by^*)$ we have if $\id \in \Ispace{T}$ 
		then $\id \in \by^*$.
		\item For all $\by \in Y$, if there is some $\id \in \by$ 
		with $\id \in \Ispace{T}$ then $\by \in \varphi\left(R_Y\right)$. 
	\end{enumerate} 
\end{definition}

Injectivity of $\varphi$ ensures that each $\by^* \in R_Y$ corresponds to exactly one $\by \in Y$.
Condition~(1) enforces per-record soundness, i.e., every identifier in a reconstructed record
appears in the corresponding original record.
Condition~(2) captures $\Ispace{T}$-restricted per-record completeness i.e., each reconstructed record contains all identifiers from its original record that also appear in $\Ispace{T}$.
Finally, Condition~(3) enforces $\Ispace{T}$-restricted global completeness i.e., all records
containing an identifier from $\Ispace{T}$ are at least partially reconstructed.


% Furthermore, we do not require the order of identifiers within records to match between \setV{} and \recVT.
% This is mainly due to the fact that the identifiers within records of \setV{} are randomly shuffled.
% However, in real-world use cases these identifiers will often be 
% syntactically clearly distinguishable attributes 
% like email addresses, phone numbers and IP addresses, 
% which allows for a later reconstruction (or at least re-alignment) 
% of the identifier order within the reconstructed records.
\begin{figure}[t]
    \centering
    \subfloat[\label{fig:target-set-example}Target set $T$.]%
    {
    \includegraphics[width=0.29\columnwidth]{figures/target-set.pdf}} 
    \quad
	\subfloat[\label{fig:victim-set-example}Victim set $Y$.]%
    {
    \includegraphics[width=0.294\columnwidth]{figures/victim-set.pdf}} 
    \quad
    \subfloat[\label{fig:max-recon-output} Max recon. ]%
    {
    \includegraphics[width=0.195\columnwidth]{figures/max-recon.pdf}}
    \caption{
    A maximum reconstruction $R_Y$. Each matched record in $Y$ corresponds to exactly one record in $R_Y$, and all identifiers shared between the matched record and the target set $T$ appear in the corresponding record $R_Y$.
    \label{fig:maximum-reconstruction-example}}
\end{figure}