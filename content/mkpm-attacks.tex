\section{Analysis of Meta's MKPM Protocol}

In this section, we describe three powerful attacks that exploit the ``leaky'' functionality $\calF_{\LMKPM}$. 
The authors of MK-PrivateID \cite{MKPMC} acknowledge the existence of their protocolâ€™s leakage but deem it acceptable as an aggregate metric that would only cause concern in multiple executions. We contradict this by presenting three attacks that achieve Maximum Set Reconstruction with only a single protocol invocation.

We first present a baseline attack that is highly efficient but relies on a strong assumption on the protocol inputs. We then describe two additional attacks that progressively relax these assumptions.
All three attacks preprocess the target set $T$ so that the resulting records are uniquely identifiable from the protocol output in a single invocation. This allows the adversary to map hidden identifiers revealed by the leakage back to their plaintext values. 

Recall that the output of $\calF_{\LMKPM}$ to party $P_1$ is
\[
(\UID, \MX, \leak_1) = (\UID, \MX, (\hXone, \hYone)),
\]
where $\UID$ denotes the set of all assigned UIDs, $\MX$ is the local mapping from UIDs to records in $X$, and $(\hXone, \hYone)$ are the hidden, shuffled records of $X$ and $Y$, respectively.


\subsection{The Baseline Attack}
\label{sec:baseline-attack}

We first observe that record matching is trivial when the target set contains a single record.
Exploiting this, our baseline attack flattens the target set $T$ into a modified input table $X$ with one record containing all identifiers in $\Ispace{T}$.
Evaluating this record against the victim set via $\leak_1$ yields unambiguous matches.

Recall that the records in $X$ are hidden and shuffled, while the order of identifiers within each record is preserved to support prioritized matching.
The baseline attack leverages the single record in $X$ to construct a dictionary that maps hidden identifiers appearing in the leakage back to their original plaintext identifiers. This is possible because the adversary knows the plaintext record and can align it with its hidden counterpart, $\hXone$.
Applying this dictionary to the leaked, hidden records of the victim set, $\hYone$, allows the adversary to reconstruct all victim records that share at least one identifier with $T$. This results in a maximum set reconstruction of $Y$ with respect to $T$.

We omit a full proof of correctness, as the construction directly follows from the fact that all identifiers in the flattened target record are uniquely identifiable in a single invocation of $\calF_{\LMKPM}$.


\heading{Time and query complexity.}
Let $\lambda$ denote the maximum record length in $T$ and $Y$, and let $n := |T|$ and $m := |Y|$.
The attack has an asymptotic time complexity of
$\bigO{(n\lambda)^2 + \lambda m}$.
The membership check can be reduced to constant time by maintaining an auxiliary set of already added identifiers, as set membership can be tested in constant time.
The attack requires only one protocol invocation and therefore establishes a tight lower bound on the number of queries needed to achieve MR.


\subsubsection{A First Optimization}
This baseline attack relies on an atypical input structure is both unnatural and easily detectable in practice, namely a table containing a single, long record. This limitation motivates the more refined attacks presented next, which achieve similar reconstruction goals while avoiding conspicuous, adversarial input patterns.

One can avoid using arbitrarily long records by exploiting the fact that record lengths are preserved in the protocol leakage.
Specifically, the identifiers in the target set $T$ can be partitioned into multiple smaller records, each of a \emph{unique} length. Let $X'$ denote the resulting table of unique-length records and ${\hXone}'$ the corresponding leaked, hidden records.
Because each record has a distinct length and the identifier order within records is preserved, the adversary can still establish a unique correspondence between the values in ${\hXone}'$ and the plaintext identifiers in $X'$. Consequently, any identifier shared between $Y$ and $X'$ can be inferred by identifying values common to $\hYone$ and ${\hXone}'$ and then mapping them back to their plaintext identifiers via $X'$.


\heading{Time and query complexity.} This optimized attack also requires one protocol query and has a time complexity of \bigO{(n\lambda)^2 + \lambda m}.
However, the maximum record length has decreased from $|\Ispace{T}|$ to $\frac{\sqrt{1+8|\Ispace{T}|}-1}{2} \approx \sqrt{2|\Ispace{T}|}$. While (arguably) less conspicuous than the single-record variant,  the victim can still detect such an attack by checking whether the adversary's input contains no two records with the same length. In our next two attacks, we thus remove this assumption.

\subsection{Record Enumeration Attack}\label{sec:rec_enum_attack}

In this subsection, we present a more general attack that applies even when all records in the target set have equal length.
For clarity, we assume that every record in the target set $T$ contains exactly $\lambda$ identifiers for some $\lambda \in \NN$; however, the attack extends directly to target sets with records of varying lengths.

We refer to this attack as the \emph{Record Enumeration Attack}. It relies only on two properties of the extended functionality $\calF_{\LMKPM}$: (i) the order of identifiers within each target record is preserved in the leakage, and (ii) identifiers are hidden deterministically, so that repeated occurrences of the same identifier yield the same hidden value within a single protocol execution.


\begin{figure}[t]
    \centering
    \def\rowspace{-.4pt}
    \def\minwidthemail{2.5cm}
    \def\minwidthphone{2.5cm}
    \def\minwidthid{.6cm}
    \def\linecorr{-.4pt}
    \def\blockminheight{1.4em}
    \definecolor{added-id}{HTML}{15b01a}
    \definecolor{matched-light}{HTML}{DCEDC8}
    \definecolor{matched-dark}{HTML}{C4E1A3}
    \definecolor{tiebreaker}{HTML}{A3CEE1}
    \definecolor{highlight-blue}{HTML}{4A90E2} 
    % Subfigures
    \subfloat[Target set $T$ (boxed in blue) and input set $X$ (the entire table).\label{subfig:recenum_example_plain}]{
        \resizebox{1\columnwidth}{!}{%
        \input{figures/recenum_example_plain.tex}
        }
    }
    \quad
    \subfloat[The hidden, shuffled leakage $\hXone$.\label{subfig:recenum_example_leakage}]{
        \resizebox{0.48\columnwidth}{!}{%
        \input{figures/recenum_example_leakage.tex}
        }
    }
    \caption{
    An example of a target set transformation by \recenumattack.
    (\ref{subfig:recenum_example_plain}) shows the target set $T$ (blue box) and the input set $X$, extended with prepended encoding identifiers (green box). 
    Note the second identifier $\id_2$ in the last record.
    (\ref{subfig:recenum_example_leakage}) shows the hidden, shuffled protocol records of $P_1$, $\hXone$.
    The hidden identifiers corresponding to $(\id_0,\id_0)$ are highlighted in green, and that corresponding to $\id_2$ is highlighted in blue.
    }
    \label{fig:recenum_example}
\end{figure}



We leverage these properties by enumerating the records in the target set $T$ and prepending to each record an encoding of its index using known identifiers.
If this enumeration can be recovered from the protocol leakage, we can construct a dictionary $\Dict$ from hidden to plaintext identifiers (see procedure $\dictInfer$ in \ref{fig:dict_infer}) and then use $\Dict$ to output a maximum reconstruction of the victim's input $Y$.

Concretely, let $\id_0$ and $\id_1$ be two distinct identifiers (whether they already occur in the target or victim sets does not matter).
Fix an ordering $(\bt_0,\ldots,\bt_{n-1})$ of the records in $T$, where $\bt_i$ denotes the $i$-th record.
Each index $i \in [0,n-1]$ is encoded as a binary string of length $\ell := \lceil \log_2 n\rceil$ 
where bits $0$ and $1$ are represented by $\id_0$ and $\id_1$, respectively.
This ``binary'' encoding is prepended to $\bt_i$, and we denote by $X$ the resulting set of extended records.

See Figure~\ref{subfig:recenum_example_plain} for a small example. The encoding procedure \IdxToSeq{} is given in Figure~\ref{fig:idx_to_seq}.

We now analyze the leakage produced by invoking MK-PrivateID on the modified input $X$. Let $(\hXone,\hYone)$ denote the additional leakage revealed to the adversarial party $P_1$. Recall that $\calF_{\LMKPM}$ hides identifiers via an injective random function $f_X$ while preserving the order of identifiers within records of $X$. Consequently, for any $\hbx \in \hXone$, the first $\ell$ positions correspond exactly to the encoded prefix and therefore contain only two hidden identifiers, say $e$ and $e'$. Moreover, either $(e,e') = (f_X(\id_0), f_X(\id_1))$ or $(e,e') = (f_X(\id_1), f_X(\id_0))$.

By distinguishing between these two cases, the adversary can recover the index $i$ encoded in the prefix of $\hbx$ and thereby establish a correspondence between the hidden identifiers in $\hXone$ and the plaintext identifiers in $X$. The decoding procedure is formalized by $\SeqToIdx$ in Figure~\ref{fig:seq_to_idx}.
To determine whether a hidden identifier $e$ corresponds to $\id_0$ or $\id_1$, we assume that $n$ is not a power of two, i.e., $|T| < 2^\ell$. As such, no record is assigned index $2^\ell - 1$, and the corresponding encoding $(\id_1,\ldots,\id_1)$ never appears. This asymmetry serves as a tiebreaker: the encoding of index $0$, namely $(\id_0,\ldots,\id_0)$, must occur.

In the leakage, this record is easily identified as the unique element of $\hXone$ whose first $\ell$ identifiers are all equal. Let $\hbx_0$ denote this record. It follows immediately that $\hbx_0[1] = f_X(\id_0)$, allowing the adversary to distinguish $f_X(\id_0)$ from $f_X(\id_1)$ and decode all remaining prefixes.

The assumption that $n$ is not a power of two is without loss of generality.
If $T$ is a power of two, the adversary can simply add or remove a single record from the target set.
Altneratively, it can introduce a third, tie-breaking identifier $\id_2 \notin {\id_0,\id_1}$ and modify the encoding of the index $2^\ell-1$ by replacing its last symbol in $(\id_1,\ldots,\id_1)$ with $\id_2$. This modification guarantees a unique, identifiable prefix and removes the ambiguity between the encoding of $0$ and $2^n$. We adopt this tie-breaking approach in our presentation of the attack.

An example of such leakage for the enumerated target set is shown in Figure~\ref{subfig:recenum_example_leakage}. The complete record enumeration attack is formalized in Figure~\ref{fig:rec_enum_attack}.


\begin{figure*}
	\pchspace
	\begin{pchstack}[boxed, center]
	\begin{pcvstack}
	\procedure[linenumbering]{$\recenumattack^{\calF_{\LMKPM}(\cdot, Y)}(T)$}{
    \rule{0pt}{2em}%
        \text{Choose three distinct identifiers } \id_0, \id_1, \id_2 \gets \calI \\
        \text{Fix an ordering } T = (\bt_0,\ldots,\bt_{n-1}). \\
        \ell \gets \lceil \log_2 n \rceil \\
        \pcfor i = 0,\ldots,n-1 \pcdo \\
             \t \bs \gets \IdxToSeq(i,\ell,\id_0,\id_1,\id_2) \\
             \t \bx_i \gets \bs \| \bt_i \label{lin:recenum_extend}\\
        X \gets (\bx_0,\ldots,\bx_{n-1}) \\
        (\UID,\MC,(\hXone,\hYone)) \sample \calF_{\LMKPM}(X,Y)\label{lin:recenum_eval} \pcskipln\\
        %%
        \cmmnt{Identify the hidden encoding of $\id_0$.} \\
        \text{Find } \hbx_0 \in \hXone \text{ s.t. } 
        \hbx_0[0]=\cdots=\hbx_0[\ell-1] \label{lin:recenum_find0}\\
        e_0 \gets \hbx_0[1] \label{lin:recenum_e0}        \pcskipln \\
        \cmmnt{Construct substitution dictionary $\Dict$} \\
        \text{Initialize empty dictionary $\Dict$.} \\
        \pcfor \hbx \in \hXone \pcdo \label{lin:recenum_dict_start}\\
            \t i \gets \SeqToIdx(\hbx,\ell,e_0) \\
            \t \pcfor j = 0,\ldots,|\hbx|-1 \pcdo \\
                \t\t \Dict[\hbx[j]] \gets \bx_i[j] \label{lin:recenum_dict_end}\\
        R_Y \gets \dictInfer(\hYone, \Dict) \\
        \pcreturn R_Y
	}
	\end{pcvstack}
	\pchspace
	\begin{pcvstack}
	\procedure[linenumbering, lnstart=18]{$\IdxToSeq(i, \ell, \id_0, \id_1, \id_2)$}{
    \rule{0pt}{2em}%
		\pcif i = 2^\ell - 1 \pcthen \\
		\t	\pcreturn (\id_1)^{\ell - 1} \| \id_2 \\
		\bs \gets () \\
		b \gets \Bin_\ell(i)\\
		\pcfor j = 0,\dots, \ell-1 \pcdo \label{lin:idx_to_seq_bin_encode_start}\\
		\t	\pcif b_j = 0 \pcthen \\
		\t	\t 	\bs \gets \bs \| \id_0 \\
		\t	\pcelse \\
        \t  \t  \bs \gets \bs \| \id_1 \label{lin:idx_to_seq_bin_encode_end} \\
		\pcreturn \bs
	}
	\procedure[linenumbering, lnstart=28]{$\SeqToIdx(\hbx, \ell, e_0)$}{
    \rule{0pt}{2em}%
		\pcif \text{for all } j \in [\ell],\ \hbx[j] \neq e_0 \pcthen \label{lin:seq_to_idx_tiebreak} \pcskipln\\
		\t \cmmnt{Encoding is $(\id_1, \dots, \id_1, \id_2)$} \\
		\t	\pcreturn 2^\ell - 1\\
		i \gets 0 \\
		\pcfor j = 0, \dots, \ell -1 \pcdo \\
		\t	\pcif \bs[j] \neq e_0 \pcthen \\
		\t	\t	i \gets i + 2^{\ell - i} \\
		\pcreturn i
	}
	\end{pcvstack}
    \begin{pcvstack}
    \procedure[linenumbering]{$\dictInfer(\hYone, \Dict)$}{
    \rule{0pt}{2em}%
		\text{Initialize $R\gets \emptyset$} \\
		\pcfor \hby \in \hYone \pcdo \\
		\t	\br \gets () \\
		\t	\pcfor i = 0, \dots, |\hby|-1 \pcdo \\
		\t	\t	\pcif \hby[i] \in \Dict \pcthen \label{lin:substitute_membership_check} \\
		\t	\t	\t	\br \gets \br \| \Dict[\hby[i]] \label{lin:substitute_add_id} \\
		\t	R \gets R \cup \{\br\} \label{lin:substitute_add_record}\\
		\pcreturn R
    }
    \end{pcvstack}
	\end{pchstack}
	\caption{Record enumeration attack $\recenumattack$ with oracle access to the extended MK-PrivateID functionality $\calF_{LMKPM}(\cdot, Y)$. 
	Note that $Y$ is part of the oracle and not known to the adversary.}\label{fig:rec_enum_attack}\label{fig:idx_to_seq}\label{fig:seq_to_idx}\label{fig:dict_infer}
\end{figure*}



\begin{theorem}\label{thm:recenumattack:correctness}
	Let $T$ be the adversary's target set and $Y$ be the victim's input.
    $\recenumattack^{\calF_\LMKPM(\cdot, Y)}(T)$ (Figure~\ref{fig:rec_enum_attack}) produces a maximum reconstruction of $Y$ with respect to $T$ (Def.~\ref{def:max_recons}).
\end{theorem}

The proof of Theorem~\ref{thm:recenumattack:correctness} can be found in Appendix~\ref{sec:recenumattack:correctness}.




\heading{Time and query complexity.}
% Assuming $\binary{\ell}(i)$ can be determined in time $\bigO{\ell}=\bigO{\log n}$, 
% \IdxToSeq{} requires time $\bigO{\ell}$.
% The same holds for \SeqToIdx{}.
% Encoding the target set therefore requires time \bigO{n\log_2 n}.
% Finding $t^*_0$ requires iterating over $\leak_{\setT'}$ and inspecting the first $\ell$ identifiers of each record,
% incurring an effort of \bigO{n\log_2 n} as well.
% The construction of $D$ requires \bigO{n (\log_2 n + \lambda)} time
% and \dictInfer{} \bigO{\lambda m}, as previously established.
% This results in an overall time complexity of \bigO{n (\log_2 n + \lambda) + \lambda m}.
% Like the baseline attack, \recenumattack{} requires only a single protocol invocation.

% \textbf{Discussion.}
% Compared to the baseline attack, the records are now much shorter and are of uniform length.
% Specifically, records are now of length $\lceil \log_2 n\rceil + \lambda$,
% where $\lambda$ denotes the original record length in the target set.
% Ignoring the constant $\lambda$, this is an exponential reduction from the maximum record lengths 
% $|\Ispace{\setT}|$ and $\approx \sqrt{2|\Ispace{\setT}|}$
% for the baseline attack and its first optimization respectively.
% At the same time, \recenumattack{} makes considerably weaker assumptions on the set of admissible inputs, thus,
% resulting in a clear improvement.

% The mitigation of the record enumeration attack is clearly more 
% involved than with the baseline attack,
% since MK-PrivateID heavily relies on the preservation of the identifier order 
% and the deterministic hiding of identifiers
% in order to compute its multi-key matching logic (see \cref{fig:match_logic}).
% A simple approach is to limit record lengths to smaller than $\lceil \log_2 n\rceil$,
% in order to prohibit an exhaustive enumeration of all records.
% However, there are more space-efficient encodings that require fewer identifiers to be added. 
% For instance, using a base-$(\ell + 1)$ encoding and omitting certain indices
% allows us to encode and recover $(\ell + 1)^\ell - \ell^2$ records with prefixes of length $\ell$.
% It is therefore unclear, what the maximum allowed record length should be.

% Other mitigation strategies that inspect the input directly
% such as limiting the maximum number occurrences per identifier are effective, 
% but burden the victim with additional computation.
% Moreover, they too become complex when trying to guard against various different encodings.
% Limiting the number of occurrences of any identifier specifically 
% comes at the additional risk of accidentally prohibiting honest protocol executions, 
% since certain types of identifiers may naturally occur often.
% IP addresses behind a Network Address Translation (NAT) device serve as an immediate example.

\section{Snake Attack}\label{sec:snake_attack}
% \begin{figure}
% 	\centering
% 	{\def\rowspace{.4cm}
% 	\def\minwidthemail{2cm}
% 	\def\minwidthphone{2.1cm}
% 	\def\minwidthid{.6cm}
% 	\def\linecorr{-.4pt}
% 	\def\blockminheight{1.3em}
% 	\definecolor{added-id}{HTML}{15b01a}
% 	\begin{subfigure}[t][][c]{0.48\textwidth}
% 		\centering
% 		\input{chapters/figures/snake_encode1_example.tex}
% 		\caption{}
% 		\label{subfig:snake_example_unique}
% 	\end{subfigure}
% 	\begin{subfigure}[t][][c]{0.48\textwidth}
% 		\centering
% 		\input{chapters/figures/snake_encode2_example.tex}
% 		\caption{}
% 		\label{subfig:snake_example_general}
% 	\end{subfigure}
% 	}
% 	\caption{Results of preprocessing a set of records \textbf{(\subref{subfig:snake_example_unique})} if there is a column that only contains unique identifiers 
% 	and \textbf{(\subref{subfig:snake_example_general})} if an artificial unique column needs to be added.
% 	The original records have black borders. Added identifiers are highlighted in green. Arrows indicate the (implicit) linked list.}\label{fig:snake_exmp}
% \end{figure}
% While the record enumeration attack marks a significant improvement over the baseline attack in terms of detectability,
% the lengths of the modified records still depend on the input size.
% This is impractical, especially in scenarios with large inputs.
% In this section, we overcome this limitation with the observation that
% an order can be imposed on a set of records without explicitly assigning 
% a unique index to each record.

% Assume, for now, that there exists a column $j^*$ in \setT{} in which every identifier is unique, i.e., $|\{t[j^*] \setdsc t \in \setT\}| = |\setT|$.
% This is not an unreasonable assumption, since certain identifiers such as email addresses are usually unique across user data.
% Should no such column exist, the adversary can simply create one by selecting $n$ distinct identifiers
% and prepending one of them to each record in \setT{}, in which case $j^* = 1$.

% We can then link the records of \setT{} by first choosing some arbitrary ordering $\setT = \{t_1, \dots, t_n\}$ 
% and appending the unique index of the $i+1$-th record to the $i$-th record for all $i \in [n-1]$.
% See \cref{subfig:snake_example_unique} for a small example. The linking procedure \snakeencodeUnique{} 
% is implemented in \cref{fig:snakeencode1}.
% The procedure outputs the modified target set $\setT'$ as a list $(t'_1, \dots, t'_n)$,
% such that $t'_i$ is located at the $i$-th position in the (implicit) linked list.

% \begin{figure*}
% 	\centering
% 	\Wider[2em]{
% 	\begin{pchstack}[boxed, center]
% 		\begin{pcvstack}
% 			\procedure[linenumbering]{$\snakeencodeUnique(j^*, (t_1, \dots, t_n))$}{
% 				\text{Initialize empty dictionary $E$.} \\
% 				\pcfor i = 1, \dots, n - 1 \pcdo \\
% 				\t	t'_i \gets t_i \ccat t_{i+1}[j^*] \\
% 				\text{Pick some $\id \not \in \{t_i[j^*] \setdsc i \in [n]\}$}  \label{lin:snake_encode_last_id}\\
% 				t'_n \gets t_n \ccat \id \\
% 				\pcreturn (t'_1, \dots, t'_n)
% 			}
% 			% \procedure[linenumbering]{$\snakeencodeGeneral(\setT)$}{
% 			% 	\text{Initialize empty dictionary $E$.} \\
% 			% 	\text{Fix some ordering $\setT = \{t_1, \dots, t_n\}$.} \\
% 			% 	\text{Pick $n+1$ distinct identifiers $\id_0, \dots \id_n \in \Ispace{}$.} \\
% 			% 	\pcfor i = 1 \dots, n \pcdo \\
% 			% 	\t	t'_i \gets \id_i \ccat t_i \ccat id_{i+1} \\
% 			% 	\t	E[i] \gets t' \\
% 			% 	\pcreturn (t'_1, \dots, t'_n)
% 			% }
% 		\end{pcvstack}
% 		\pchspace
% 		\begin{pcvstack}
% 			\procedure[linenumbering]{$\snakerecoverUnique(\leak_{\setT'}, j^*)$}{
% 				\text{Initialize empty dictionary $\loc$.}\\
% 				\text{Fix some ordering $\leak_{\setT'} = (h_1, \dots, h_n)$.} \\
% 				k' \gets |h_1| \pccomment{$= |h_2| = \dots = |h_n|$} \pcskipln\\
% 				\pclinecomment{Store locations of linked identifiers}\\
% 				\pcfor i = 1, \dots, n \pcdo \\
% 				\t	\loc[h_i[j^*]] \gets i \pcskipln\\
% 				\pclinecomment{Find start index $c$ of the linked list} \\
% 				\text{Find $c \leq n$ s.t. $h_c[j^*]\not\in\{h_i[k'] \setdsc i \in [n]\}$} \label{lin:snake_recover_c} \pcskipln\\
% 				\pclinecomment{Traverse linked list to recover original ordering}\\
% 				i \gets 1 \\
% 				\pcdo \label{lin:snake_recover_dowhile}\\
% 				\t	t^*_i := h_{c} \label{lin:snake_recover_assign_t_star}\\
% 				\t	c \gets \loc[h_c[k']] \label{lin:snake_recover_updt_c}\\
% 				\t	i \gets i + 1\\
% 				\pcwhile h_{c}[k'] \in \loc \label{lin:snake_recover_dowhile_end}\\
% 				\pcreturn (t^*_1, \dots, t^*_n)
% 			}
% 		\end{pcvstack}
% 	\end{pchstack}}
% 	\caption{Procedures \snakeencodeUnique{} and \snakerecoverUnique{}.}\label{fig:snakeencode1}\label{fig:snakedecode1}
% \end{figure*}

% Since the identifier hiding function in \LMKPM{} (see \cref{fig:MKPM}) is injective and deterministic for repeating identifiers, 
% this linkage is preserved in the protocol leakage $\leak_{\setT'}$, where $(\leak_{\setT'}, \leakV) = \leak(\setT', \setV)$.
% The adversary can therefore find the start of the linked list by finding the (unique) record whose $j^*$-th identifier
% is not appended to any other record and traverse the linked list to recover the original ordering of $\setT$.
% See procedure \snakerecoverUnique{} in \cref{fig:snakedecode1}.
% The procedure takes the target set leakage $\leak_{\setT'}$ and $j^*$ and 
% outputs the elements of $\leak_{\setT'}$ as a list $(t^*_1, \dots, t^*_n)$ such that $t^*_i$
% has index $i$ in the linked list.
% Having matched the hidden records in $\leak_{\setT'}$ with the plain records in $\setT'$,
% we can then apply the usual substitution-based transformation to infer a maximum reconstruction from \leakV{}.
% The full attack is displayed in \cref{fig:snakeattack}.

% \begin{figure}
% 	\centering
% 	\begin{pcvstack}[boxed, center]
% 		\procedure[linenumbering]{$\snakeattack^{\LMKPM(\cdot, \setV)}(\setT)$}{
% 			n \gets |\setT| \\
% 			\text{Fix some ordering $\setT = (t_1, \dots, t_n)$.}\\
% 			\pcif \text{$\lnot\exists j^*$ s.t. $|\{t_i[j^*] \setdsc i\in[n]\}| = n$} \pcthen \label{lin:distinctIDs_j*} \\
% 			\t 	\text{Pick $n$ distinct identifiers $\id_1, \dots \id_n \in \Ispace{}$.} \\
% 			\t 	\text{Prepend $\id_i$ to $t_i$ for all $i \in [n]$.}\\
% 			\t	j^* :=  1\\
% 			(t'_1, \dots, t'_n) \gets \snakeencodeUnique(j^*, (t_1, \dots, t_n)) \label{lin:snake_encode}\\
% 			(\UID, \MC, (\leak_{\setT'}, \leakV)) \sample \LMKPM(\{t'_1, \dots, t'_n\}, \setV) \label{lin:snake_evaluation}\\
% 			(t^*_1, \dots, t^*_n) \gets \snakerecoverUnique(\leak_{\setT'}, j^*) \label{lin:snake_decode}\pcskipln \\
% 			\pclinecomment{Construct substitution map $D$. }\\
% 			\text{Initialize empty dictionary $D$.} \\
% 			\pcfor i = 1, \dots, n \pcdo \label{lin:snake_D_start} \\
% 			\t	\pcfor j = 1, \dots |t| \pcdo \\
% 			\t	\t	D[t^*_i[j]] \gets t'_i[j] \label{lin:snake_D_end} \\
% 			\recVT \gets \dictInfer(\leakV{}, D) \\
% 			\pcreturn \recVT
% 		}
% 		\end{pcvstack}
% 		\caption{Snake attack with oracle access to the extended MKPM functionality $\LMKPM(\cdot, \setV)$.
% 		\setV{} is part of the oracle and unknown to the adversary.} \label{fig:snakeattack}
% \end{figure}

% \begin{theorem}
% 	For any sets of records \setT{} and \setV{}, 
% 	$\snakeattack^{\LMKPM(\cdot, \setV)}(\setT)$ produces a maximum reconstruction of \setV{} w.r.t. \setT.
% \end{theorem}
% \begin{proof}
% 	To prove the theorem, we prove the following proposition.
% 	The theorem follows directly from Proposition~\ref{thm:snake_D} and \cref{lem:dictinfer_MR}.
% \begin{proposition}
% 	\label{thm:snake_D}
% 	Let \setT{} and \setV{} be two sets of records and let $D$ be the substitution dictionary
% 	constructed during an invocation of $\snakeattack^{\LMKPM(\cdot, \setV)}(\setT)$.
% 	Moreover, let $f_C$ be the identifier hiding function sampled during the invocation of \leak{}
% 	in line~\ref{lin:snake_evaluation}.
% 	Then, we have $D[f_C(\id)] = \id$ for all $\id \in \Ispace{\setT}$.
% \end{proposition}
% \begin{proof} \textbf{of Proposition~\ref{thm:snake_D}}
% 	Let $\setT' := \{t'_1, \dots, t'_n\}$ where $t'_i$ is produced by \snakeencodeUnique{} in line~\ref{lin:snake_encode}
% 	and let $k' := |t'_i|$ for any $i\in [n]$\footnote{Recall that we assume that all records have the same length $\lambda$.
% 	Thus, $k' \in \{\lambda + 1, \lambda+2\}$}.
% 	We show that $D[f_C(\id)] = \id$ for all $\id \in \Ispace{\setT'}$.
% 	Since \snakeattack{} potentially adds fresh identifiers to records of \setT{}, but does not remove any, 
% 	we have $\Ispace{\setT}\subseteq\Ispace{\setT'}$, which implies the claim.
	
% 	Similar to the proof of \cref{thm:recenum_D}, we show that
% 	$t^*_i[j] = f_C(t'_i[j])$ for all $i\in[n]$ and all $j \in [k']$.
% 	The result then follows from the construction of $D$ in lines~\ref{lin:snake_D_start}~-~\ref{lin:snake_D_end}. 
% 	In particular, we will show that the linked list we create in \IdxToSeq{} is preserved in the leakage, 
% 	and that this linked list allows us to uniquely identify each record. 
% 	We show this by induction on $i$. 
% 	Let $j^*$ denote the index of a column whose identifiers are all unique (note that if such a column does not exist, it is created on line~\ref{lin:distinctIDs_j*}).

% 	For $i = 1$, observe that identifier $t_1[j^*]$ is not appended to any record in \snakeencodeUnique{}; 
% 	in other words, it is the only item in the linked list that doesn't have anything pointing to it.
% 	In contrast, for all $i' > 1$, identifier $t_{i'}[j^*]$ is appended to $t_{i'+1}$.
% 	$t'_1$ is therefore the only record in $\setT'$ whose $j^*$-th identifier is not contained in the last column, 
% 	i.e., $t'_1[j^*] \not \in \{t'_{i'}[k'] \setdsc i'\in[n]\}$.
% 	By the definition of $\LMKPM$, this property is preserved in the leakage $\leak_{\setT'}$.
% 	That is, the corresponding record in the leakage $h = (f_C(t'_1[1]), \dots, f_C(t'_1[k']))$
% 	is the only record in $\leak_{\setT'}$ such that such that $h[j^*]\not\in\{h_{i'}[k'] \setdsc i' \in [n]\}$.
% 	In line~\ref{lin:snake_recover_c} in \snakerecoverUnique{} we pick $h_c := h$.
% 	Thus, for all $j \in [k']$ we have that $h_c[j] = f_C(t'_1[j])$
% 	and, therefore  $t^*_1[j] = h_c[j] = f_C(t'_1[j])$, where the first equality follows from line~\ref{lin:snake_recover_assign_t_star}.

% 	Now assume that for some $i < n$ we have $t^*_i[j] = f_C(t'_i[j])$ for all $j \in [k']$. 
% 	We show that there is a unique record which $t'_i[k']$ is pointing to (that has not been traversed by the previous items in the linked list), 
% 	and that, once again this property is preserved in the leakage allowing for unique identification of the record.
% 	By construction in \snakeencodeUnique{}, we have $t'_{i+1}[j^*] = t'_i[k']$.
% 	Since all identifiers in the $j^*$-th column are distinct, 
% 	$t'_{i+1}$ is the only record in $\setT'$ that satisfies this condition.
% 	As before, since $f_C$ is injective, the corresponding record in the leakage 
% 	$h = (f_C(t'_{i+1}[1]), \dots, f_C(t'_{i+1}[k']))$
% 	is the only record that satisfies $h[j^*] = t^*_i[k']$.
% 	Moreover, all hidden identifiers in the $j^*$-th column of $\leak_{\setT'}$	are distinct. % $t'_{i+1}$ is the only record in $\setT'$
% 	Thus, the dictionary \loc{} in \SeqToIdx{} contains exactly the $n$ keys $\{f_C(t'_{i'}[j^*]) \setdsc i' \in [n]\} = \{f_C(t^*_{i'}[j^*]) \setdsc i' \in [n]\}$,
% 	which are mapped as $\loc[f_C(t'_{i'}[j^*])] = i'$.
% 	In line~\ref{lin:snake_recover_assign_t_star}, we pick $t^*_{i+1} := h_c$ for $c = \loc[t^*_i[k']]$, 
% 	implying $t^*_{i+1}[j^*] = t^*_i[k']$ and, thus, $t^*_{i+1} = h$.
% 	We therefore have $t^*_{i+1}[j] = h[j] = f_C(t'_{i+1}[j])$ for all $j \in [k']$.
% \end{proof}

% 	The statement follows from \cref{thm:snake_D} and \cref{lem:dictinfer_MR}.
% \end{proof}

% \textbf{Time and Query Complexity.} 
% Recall our assumptions that reading from, writing to, and checking for the presence of a key in a dictionary 
% requires an average-case constant time complexity.
% Then, \snakeencodeUnique{} has an asymptotic average-case time complexity of \bigO{n} for $n = |\setT|$,
% assuming \id{} in line \ref{lin:snake_encode_last_id} can be found in constant time\footnote{This is feasible with some additional assumptions on \setT. For instance, if \setT{} only contains email addresses, one may simply pick a single character for $\id$.}.
% The same holds for \snakerecoverUnique{}.
% In particular, $c$ in line~\ref{lin:snake_recover_c} can be found by inserting the last identifier of every record into a dictionary 
% and then checking for the presence of the $j^*$-th identifier of every record.
% Moreover, note that the loop in lines~\ref{lin:snake_recover_dowhile}~-~\ref{lin:snake_recover_dowhile_end}
% traverses the linked list once, executing exactly $n$ iterations.

% Let $\lambda$ denote the length of the largest record in \setT{} or \setV.
% Determining whether there exists a column in \setT{} that contains only unique identifiers
% can be done in time \bigO{\lambda n}, also assuming that dictionary insertions and lookups can be done in average-case constant time.
% Computing the dictionary $D$ requires at most $\lambda n$ write operations.
% Adding the complexity of \dictInfer{}, \bigO{\lambda m} with $m = |\setV|$,
% results in an overall average-case time complexity of \bigO{\lambda (n + m)} for \snakeattack.

% Like \toyattack{} and \recenumattack{}, \snakeattack{} requires only one protocol invocation.

% \subsection{Discussion and Mitigation}
% \label{sec:snake_mitigations}
% While requiring the same number of protocol invocations 
% and incurring a comparable computational complexity as the other attacks presented in this chapter, 
% \snakeattack{} stands out for requiring only minimal modifications to the target set to successfully carry out the attack.
% Since the records are extended by at most two identifiers, in contrast to $\log n$ (as required by \recenumattack{}),
% \snakeattack{} is also applicable to scenarios where the record length is constrained to a small constant.
% Meta's Private Computation Solution \cite{FBPCSRepo} serves as a concrete example, 
% where records are limited to at most four identifiers.
% If the target set already meets the maximum allowed record length, 
% the adversary can always rearrange the target set into shorter records and use the newly available space for the snake encoding.

% Since records are only extended by a small constant, limiting record lengths to mitigate against attacks, 
% as proposed previously, is ineffective.
% However, the chain-like structure of the modified target set, which enables recovering the original order of the identifiers,
% allows the victim to detect and mitigate the attack.
% To capture a broader variety of such linking strategies than just the approach we presented above, 
% we consider a graph $\graph(\setX) = (\vertSet_\setX, \edgeSet_\setX)$ for some set of records \setX{}, which contains one vertex for every record of the target set 
% and an edge between every pair of vertices whose corresponding records contain at least one common identifier.
% \begin{equation*}
% 	\vertSet_\setX := \{v_x \setdsc x \in \setX \}
% \end{equation*}
% \begin{equation*}
% 	\edgeSet_\setX := \{(v_x, v_{x'}) \setdsc \exists i, j. x[i] = x'[j] \}
% \end{equation*}
% As depicted in \cref{fig:snake_exmp}, the graph $\graph(\setT')$, which is generated from the modified target set $\setT'$ produced by \snakeencodeUnique{},
% only has a single connected component. 
% Furthermore, since the victims protocol leakage $\leak^P_{\setT'}$ (see \cref{fig:MKPM}) simply contains a shuffled and renamed copy of $\setT'$,
% $\graph(\setT')$ and $\graph(\leak^P_{\setT'})$ are isomorphic and thus have the same number of connected components. 
% The victim can therefore detect such linkage-based attack strategies and abort the protocol execution.
% This also defends against the record enumeration attack presented in the last section.
% However, one needs to be careful not to accidentally reject valid inputs, 
% as large connected components may occur naturally.
% The example of IP addresses behind a NAT device we mentioned in the last section also applies here.
