\section{Analysis of the L-MKPM Functionality}

In this section, we describe three powerful attacks that exploit the ``leaky'' functionality $\calF_{\LMKPM}$. 
The authors of MK-PrivateID \cite{MKPMC} acknowledge the existence of their protocolâ€™s leakage but deem it acceptable as an aggregate metric that would only cause concern in multiple executions. We contradict this by presenting three attacks that achieve Maximum Set Reconstruction with only a single protocol invocation.

We first present a baseline attack that is highly efficient but relies on a strong assumption on the protocol inputs. We then describe two additional attacks that progressively relax these assumptions.
All three attacks preprocess the target set $T$ so that the resulting records are uniquely identifiable from the protocol output in a single invocation. This allows the adversary to map hidden identifiers revealed by the leakage back to their plaintext values. 

Recall that the output of $\calF_{\LMKPM}$ to party $P_1$ is
\[
(\UID, \MX, \leak_1) = (\UID, \MX, (\hXone, \hYone)),
\]
where $\UID$ denotes the set of all assigned UIDs, $\MX$ is the local mapping from UIDs to records in $X$, and $(\hXone, \hYone)$ are the hidden, shuffled records of $X$ and $Y$, respectively.


\subsection{The Baseline Attack}
\label{sec:baseline-attack}

We first observe that record matching is trivial when the target set contains a single record.
Exploiting this, our baseline attack flattens the target set $T$ into a modified input table $X$ with one record containing all identifiers in $\Ispace{T}$.
Evaluating this record against the victim set via $\leak_1$ yields unambiguous matches.

Recall that the records in $X$ are hidden and shuffled, while the order of identifiers within each record is preserved to support prioritized matching.
The baseline attack leverages the single record in $X$ to construct a dictionary that maps hidden identifiers appearing in the leakage back to their original plaintext identifiers. This is possible because the adversary knows the plaintext record and can align it with its hidden counterpart, $\hXone$.
Applying this dictionary to the leaked, hidden records of the victim set, $\hYone$, allows the adversary to reconstruct all victim records that share at least one identifier with $T$. This results in a maximum set reconstruction of $Y$ with respect to $T$.

For convenience, we refer to this attack as the \baselineattack{}.
We omit a full proof of correctness, as the construction directly follows from the fact that all identifiers in the flattened target record are uniquely identifiable in a single invocation of $\calF_{\LMKPM}$.


\heading{Time and query complexity.}
Let $\ell_{\rec}$ denote the maximum record length in $T$ and $Y$, and let $n := |T|$ and $m := |Y|$.
The attack has an asymptotic time complexity of
$\bigO{(n\ell_{\rec})^2 + \ell_{\rec} m}$.
The membership check can be reduced to constant time by maintaining an auxiliary set of already added identifiers, as set membership can be tested in constant time.
The attack requires only one protocol invocation and therefore establishes a tight lower bound on the number of queries needed to achieve MR.

\begin{figure*}
	\input{pseudocode/recenum-code.tex}
	\caption{Record enumeration attack $\recenumattack$ with oracle access to the extended MK-PrivateID functionality $\calF_{LMKPM}(\cdot, Y)$. 
	Note that $Y$ is part of the oracle and not known to the adversary.}\label{fig:rec_enum_attack}\label{fig:idx_to_seq}\label{fig:seq_to_idx}\label{fig:dict_infer}
\end{figure*}

\begin{figure}[t]
    \centering
    \def\rowspace{-.4pt}
    \def\minwidthemail{2.5cm}
    \def\minwidthphone{2.5cm}
    \def\minwidthid{.6cm}
    \def\linecorr{-.4pt}
    \def\blockminheight{1.4em}
    \definecolor{added-id}{HTML}{15b01a}
    \definecolor{matched-light}{HTML}{DCEDC8}
    \definecolor{matched-dark}{HTML}{C4E1A3}
    \definecolor{tiebreaker}{HTML}{A3CEE1}
    \definecolor{highlight-blue}{HTML}{4A90E2} 
    % Subfigures
    \subfloat[Target set $T$ (boxed in blue) and input set $X$ (the entire table).\label{subfig:recenum_example_plain}]{
        \resizebox{1\columnwidth}{!}{%
        \input{figures/recenum_example_plain.tex}
        }
    }
    \quad
    \subfloat[The hidden, shuffled leakage $\hXone$.\label{subfig:recenum_example_leakage}]{
        \resizebox{0.48\columnwidth}{!}{%
        \input{figures/recenum_example_leakage.tex}
        }
    }
    \caption{
    An example of a target set transformation by \recenumattack.
    (\ref{subfig:recenum_example_plain}) shows the target set $T$ (blue box) and the input set $X$, extended with prepended encoding identifiers (green box). 
    Note the second identifier $\id_2$ in the last record.
    (\ref{subfig:recenum_example_leakage}) shows the hidden, shuffled protocol records of $P_1$, $\hXone$.
    The hidden identifiers corresponding to $(\id_0,\id_0)$ are highlighted in green, and that corresponding to $\id_2$ is highlighted in blue.
    }
    \label{fig:recenum_example}
\end{figure}


\subsubsection{A First Optimization}
This baseline attack relies on an atypical input structure is both unnatural and easily detectable in practice, namely a table containing a single, long record. This limitation motivates the more refined attacks presented next, which achieve similar reconstruction goals while avoiding conspicuous, adversarial input patterns.

\begin{figure*}[ht!]
    \centering
    \vspace{0pt}
	\input{pseudocode/snake-code.tex}
    \caption{Snake attack with oracle access to the extended MKPM functionality $\calF_{\LMKPM}(\cdot, Y)$. $Y$ is part of the oracle and unknown to the adversary.\label{fig:snakeattack}\label{fig:snakeencode1}\label{fig:snakedecode1}} 
\end{figure*}


One can avoid using arbitrarily long records by exploiting the fact that record lengths are preserved in the protocol leakage.
Specifically, the identifiers in the target set $T$ can be partitioned into multiple smaller records, each of a \emph{unique} length. Let $X'$ denote the resulting table of unique-length records and ${\hXone}'$ the corresponding leaked, hidden records.
Because each record has a distinct length and the identifier order within records is preserved, the adversary can still establish a unique correspondence between the values in ${\hXone}'$ and the plaintext identifiers in $X'$. Consequently, any identifier shared between $Y$ and $X'$ can be inferred by identifying values common to $\hYone$ and ${\hXone}'$ and then mapping them back to their plaintext identifiers via $X'$.


\heading{Time and query complexity.} This optimized attack also requires one protocol query and has a time complexity of \bigO{(n\ell_{\rec})^2 + \ell_{\rec} m}.
However, the maximum record length has decreased from $|\Ispace{T}|$ to $\frac{\sqrt{1+8|\Ispace{T}|}-1}{2} \approx \sqrt{2|\Ispace{T}|}$. While (arguably) less conspicuous than the single-record variant,  the victim can still detect such an attack by checking whether the adversary's input contains no two records with the same length. In our next two attacks, we thus remove this assumption.

\subsection{Record Enumeration Attack}\label{sec:rec_enum_attack}

In this subsection, we present a more general attack that applies even when all records in the target set have equal length.
For clarity, we assume that every record in the target set $T$ contains the same number of identifiers, however, the attack extends directly to target sets with records of varying lengths.

We refer to this attack as the \emph{Record Enumeration Attack}. It relies only on two properties of the extended functionality $\calF_{\LMKPM}$: (i) the order of identifiers within each target record is preserved in the leakage, and (ii) identifiers are hidden deterministically, so that repeated occurrences of the same identifier yield the same hidden value within a single protocol execution.




We leverage these properties by enumerating the records in the target set $T$ and prepending to each record an encoding of its index using known identifiers.
If this enumeration can be recovered from the protocol leakage, we can construct a dictionary $\Dict$ from hidden to plaintext identifiers (see procedure $\dictInfer$ in \ref{fig:dict_infer}) and then use $\Dict$ to output a maximum reconstruction of the victim's input $Y$.

Concretely, let $\id_0$ and $\id_1$ be two distinct identifiers (whether they already occur in the target or victim sets does not matter).
Fix an ordering $(\bt_0,\ldots,\bt_{n-1})$ of the records in $T$, where $\bt_i$ denotes the $i$-th record.
Each index $i \in [0,n-1]$ is encoded as a binary string of length $\ell := \lceil \log_2 n\rceil$ 
where bits $0$ and $1$ are represented by $\id_0$ and $\id_1$, respectively.
This ``binary'' encoding is prepended to $\bt_i$, and we denote by $X$ the resulting set of extended records.

See Figure~\ref{subfig:recenum_example_plain} for a small example. The encoding procedure \IdxToSeq{} is given in Figure~\ref{fig:idx_to_seq}.

We now analyze the leakage produced by invoking MK-PrivateID on the modified input $X$. Let $(\hXone,\hYone)$ denote the additional leakage revealed to the adversarial party $P_1$. Recall that $\calF_{\LMKPM}$ hides identifiers via an injective random function $f_X$ while preserving the order of identifiers within records of $X$. Consequently, for any $\hbx \in \hXone$, the first $\ell$ positions correspond exactly to the encoded prefix and therefore contain only two hidden identifiers, say $e$ and $e'$. Moreover, either $(e,e') = (f_X(\id_0), f_X(\id_1))$ or $(e,e') = (f_X(\id_1), f_X(\id_0))$.

By distinguishing between these two cases, the adversary can recover the index $i$ encoded in the prefix of $\hbx$ and thereby establish a correspondence between the hidden identifiers in $\hXone$ and the plaintext identifiers in $X$. The decoding procedure is formalized by $\SeqToIdx$ in Figure~\ref{fig:seq_to_idx}.
To determine whether a hidden identifier $e$ corresponds to $\id_0$ or $\id_1$, we assume that $n$ is not a power of two, i.e., $|T| < 2^\ell$. As such, no record is assigned index $2^\ell - 1$, and the corresponding encoding $(\id_1,\ldots,\id_1)$ never appears. This asymmetry serves as a tiebreaker: the encoding of index $0$, namely $(\id_0,\ldots,\id_0)$, must occur.

In the leakage, this record is easily identified as the unique element of $\hXone$ whose first $\ell$ identifiers are all equal. Let $\hbx_0$ denote this record. It follows immediately that $\hbx_0[1] = f_X(\id_0)$, allowing the adversary to distinguish $f_X(\id_0)$ from $f_X(\id_1)$ and decode all remaining prefixes.

The assumption that $n$ is not a power of two is without loss of generality.
If $T$ is a power of two, the adversary can simply add or remove a single record from the target set.
Altneratively, it can introduce a third, tie-breaking identifier $\id_2 \notin {\id_0,\id_1}$ and modify the encoding of the index $2^\ell-1$ by replacing its last symbol in $(\id_1,\ldots,\id_1)$ with $\id_2$. This modification guarantees a unique, identifiable prefix and removes the ambiguity between the encoding of $0$ and $2^n$. We adopt this tie-breaking approach in our presentation of the attack.

An example of such leakage for the enumerated target set is shown in Figure~\ref{subfig:recenum_example_leakage}. The complete record enumeration attack is formalized in Figure~\ref{fig:rec_enum_attack}.





\begin{theorem}\label{thm:recenumattack:correctness}
	Let $T$ be the adversary's target set and $Y$ be the victim's input.
    $\recenumattack^{\calF_\LMKPM(\cdot, Y)}(T)$ (Figure~\ref{fig:rec_enum_attack}) produces a maximum reconstruction of $Y$ with respect to $T$ (Def.~\ref{def:max_recons}).
\end{theorem}

The proof of Theorem~\ref{thm:recenumattack:correctness} can be found in Appendix~\ref{sec:recenumattack:correctness}.




\heading{Time and query complexity.}
Assuming that $\Bin_\ell(i)$ can be computed in time $\bigO{\ell} = \bigO{\log n}$, both $\IdxToSeq$ and $\SeqToIdx$ run in time $\bigO{\ell}$. Encoding the target set therefore takes time $\bigO{n \log n}$.
Identifying $\hbx_0$ requires scanning $\hXone$ and checking the first $\ell$ identifiers of each record, which also incurs time $\bigO{n \log n}$. Constructing the dictionary $\Dict$ takes time $\bigO{n(\log n + \lambda)}$, while applying $\dictInfer$ to the victim leakage requires time $\bigO{\lambda m}$, as established earlier.

Overall, the attack runs in time \bigO{n (\log_2 n + \lambda) + \lambda m} and---like \baselineattack{}---\recenumattack{} requires only a single query.

% \textbf{Discussion.}
% Compared to the baseline attack, the records are now much shorter and are of uniform length.
% Specifically, records are now of length $\lceil \log_2 n\rceil + \lambda$,
% where $\lambda$ denotes the original record length in the target set.
% Ignoring the constant $\lambda$, this is an exponential reduction from the maximum record lengths 
% $|\Ispace{\setT}|$ and $\approx \sqrt{2|\Ispace{\setT}|}$
% for the baseline attack and its first optimization respectively.
% At the same time, \recenumattack{} makes considerably weaker assumptions on the set of admissible inputs, thus,
% resulting in a clear improvement.



\subsection{Snake Attack}\label{sec:snake_attack}
\begin{figure}
	\centering
	{\def\rowspace{.4cm}
	\def\minwidthemail{2cm}
	\def\minwidthphone{2.1cm}
	\def\minwidthid{.6cm}
	\def\linecorr{-.4pt}
	\def\blockminheight{1.3em}
	\definecolor{added-id}{HTML}{15b01a}
    \subfloat[\label{subfig:snake_example_unique}]{
        \resizebox{0.85\columnwidth}{!}{%
        \input{figures/snake_encode1_example.tex}
        }
    }
    \quad
	\subfloat[\label{subfig:snake_example_general}]{
        \resizebox{0.85\columnwidth}{!}{%
        \input{figures/snake_encode2_example.tex}
        }
    }
	}
	\caption{Results of preprocessing a set of records \textbf{(\ref{subfig:snake_example_unique})} if there is a column that only contains unique identifiers 
	and \textbf{(\ref{subfig:snake_example_general})} if an artificial unique column needs to be added.
	The original records have black borders. Added identifiers are highlighted in green. Arrows indicate the (implicit) linked list.}\label{fig:snake_exmp}
\end{figure}


While the record enumeration attack improves over the baseline in terms of detectability, it still requires an input whose record lengths grow with the target set size. We address this limitation by imposing an order on the records without explicitly assigning a unique index to each one. This approach extends each record by only two identifiers.

The attack starts by checking whether there exists a column $j^*$ in $T$ in which every identifier is unique, i.e., $|\{\bt[j^*] \setdsc \bt \in T\}| = |T|$.
This is a reasonable assumption since many identifiers such as email addresses are usually unique across users.
If no such column exists, the adversary can create one by sampling $n$ distinct identifiers
and prepending each identifier to a distinct  record in $T$ (in this case $j^* = 0$).

We can then link the records of $T$ by first choosing some arbitrary ordering $T= \{\bt_0, \dots, \bt_{n-1}\}$ and appending the unique index of the $i+1$-th record to the $i$-th record for all $i \in [n-1]$.
See Figure~\ref{subfig:snake_example_unique} for a small example. The linking procedure \snakeencodeUnique{} outputs the modified target set $X$ as a list $(\bx_0, \dots, \bx_{n-1})$, such that $\bt_i$ corresponds to $\bx_i$ in the (implicit) linked list.

Since the identifier hiding function in $\calF_\LMKPM$ is injective and deterministic for repeating identifiers, the pointers are preserved in the leakage $\hXone$.
The adversary can therefore find the start of the linked list by finding the (unique) record whose $j^*$-th identifier is not appended to any other record and traverse the linked list to recover the original ordering of $X$.


The procedure \snakerecoverUnique{} takes the input set leakage $\hXone$ and $j^*$ and outputs the elements of $\hXone$ as a list $(\bs_0, \dots, \bs_{n-1})$ such that $\bs_i$ has index $i$ in the linked list. Once the hidden records in $\hXone$ are matched with the corresponding plaintext records in $X$, we can apply a substitution-based transformation to recover a maximum reconstruction from $\hYone$.

The pseudocode for the full attack are given in Figure~\ref{fig:snakeattack}.



\begin{theorem}\label{thm:snakeattack:correctness}
	Let $T$ be the adversary's target set and $Y$ be the victim's input.
    $\snakeattack^{\calF_\LMKPM(\cdot, Y)}(T)$ (Figure~\ref{fig:rec_enum_attack}) produces a maximum reconstruction of $Y$ with respect to $T$ (Def.~\ref{def:max_recons}).
\end{theorem}

The proof of Theorem~\ref{thm:snakeattack:correctness} can be found in Appendix~\ref{sec:snakeattack:correctness}.

\heading{Time and query complexity.} 
Assuming \id{} in line \ref{lin:snake_encode_last_id} can be located in constant time, \snakeencodeUnique{} has an average-case time complexity of \(\bigO{n}\) for \(n = |T|\). The same applies to \snakerecoverUnique. Finding the starting index in line \ref{lin:snake_recover_c} involves inserting the last identifier of each record into a dictionary and checking for the presence of the \(j^*\)-th identifier, while the loop in lines \ref{lin:snake_recover_dowhile}--\ref{lin:snake_recover_dowhile_end} performs \(n\) iterations, traversing the linked list once.

Let \(\ell_{\rec}\) denote the length of the largest record in either \(T\) or \(Y\). Determining whether a column in \(T\) contains only unique identifiers can be done in $\bigO{\ell_{\rec} n}$ time, assuming that dictionary operations are average-case constant time. Constructing the dictionary $\Dict$ involves up to \(\ell_{\rec} n\) writes. Factoring in \dictInfer's \(\bigO{\ell_{\rec} m}\) complexity with \(m = |Y|\), the overall average-case time complexity for \snakeattack{} is \(\bigO{\ell_{\rec} (n + m)}\). Similar to the previous attacks, \snakeattack{} requires only one protocol invocation.

% \heading{Discussion and mitigation.}
% While requiring the same number of protocol invocations and incurring a comparable computational complexity to the other attacks, \snakeattack{} stands out for requiring only minimal modifications to the target set and is applicable to scenarios where the record length is constrained to a small constant.
% Meta's Private Computation Solution \cite{FBPCSRepo} serves as a concrete example, where records are limited to at most four identifiers. If the target set already meets the maximum allowed record length, the adversary can always rearrange the target set into shorter records and use the available space for the snake encoding.

% Since records are only extended by a small constant, limiting record lengths to mitigate against attacks, 
% as proposed previously, is ineffective.
% However, the chain-like structure of the modified target set, which enables recovering the original order of the identifiers,
% allows the victim to detect and mitigate the attack.
% To capture a broader variety of such linking strategies than just the approach we presented above, 
% we consider a graph $\graph(\setX) = (\vertSet_\setX, \edgeSet_\setX)$ for some set of records \setX{}, which contains one vertex for every record of the target set 
% and an edge between every pair of vertices whose corresponding records contain at least one common identifier.
% \begin{equation*}
% 	\vertSet_\setX := \{v_x \setdsc x \in \setX \}
% \end{equation*}
% \begin{equation*}
% 	\edgeSet_\setX := \{(v_x, v_{x'}) \setdsc \exists i, j. x[i] = x'[j] \}
% \end{equation*}
% As depicted in \cref{fig:snake_exmp}, the graph $\graph(\setT')$, which is generated from the modified target set $\setT'$ produced by \snakeencodeUnique{},
% only has a single connected component. 
% Furthermore, since the victims protocol leakage $\leak^P_{\setT'}$ (see \cref{fig:MKPM}) simply contains a shuffled and renamed copy of $\setT'$,
% $\graph(\setT')$ and $\graph(\leak^P_{\setT'})$ are isomorphic and thus have the same number of connected components. 
% The victim can therefore detect such linkage-based attack strategies and abort the protocol execution.
% This also defends against the record enumeration attack presented in the last section.
% However, one needs to be careful not to accidentally reject valid inputs, 
% as large connected components may occur naturally.
% The example of IP addresses behind a NAT device we mentioned in the last section also applies here.
