\section{Preliminaries Supplementary Content}\label{ap:mkpc}

\begin{figure}[H]
	\fbox{%
    \begin{minipage}[t]{0.98\columnwidth}
		\textbf{Parameters:} Two parties, $C$ and $P$.\\
		\noindent\textbf{Functionality:} $\calF_{\SKPM}(X, Y)$: 
        \hfill \begin{enumerate}
			\item Receive the input from party $P_1$: $X = \{x_i \setdsc i \in [n]\}$
			\item Receive the input from party $P_2$: $Y = \{y_i \setdsc i \in [m]\}$
			\item Compute $Z := X \cup Y$.
			\item Sample $f \sample \InjFuncs[\Ispace, \calG]$.
			\item Compute dictionaries
            $\MX : \calG \to X \cup \{\bot\}$ and $\MY : \calG \to Y \cup \{\bot\}$ s.t. for all $z \in Z$:
			\[
				\MX[f(z)] = \begin{cases*}
					z & if $z \in X$ \\
					\bot & otw.
				\end{cases*} \\
            \]
            \[
				\MY[f(z)] = \begin{cases*}
					z & if  $z \in Y$ \\
					\bot & otw.
				\end{cases*}
            \]
		\item Compute $\UID \gets \{f(z) \setdsc z \in Z\}$.
		\item Output:
            \begin{itemize}
                \item Send $\UID, \MX$ to $P_1$.
                \item Send $\UID, \MY$ to $P_2$.
			\end{itemize}
	\end{enumerate}  
    \end{minipage}
    }
	\caption{The Single-Key Private Matching functionality $\calF_{\SKPM}$, implemented by Meta's PrivateID protocol \cite{PMC}.}\label{fig:SKPM_definition}
\end{figure}



\begin{figure}[H]
	\begin{pchstack}[boxed, center]
		\procedure[linenumbering, skipfirstln]{$\match(X, Y)$}{ 
			\pclinecomment{Recall that $X = \{\bx_1, \dots, \bx_n\}, Y = \{\by_1, \dots, \by_n\}$} \\
			\text{Initialize empty maps $\MX$ and $\MY$.} \\
			\text{Initialize empty set $\UID$.} \\
			\mathsf{matched}^{X} \gets (\bot)^n; \; \mathsf{matched}^{Y} \gets (\bot)^m \\
			n_{max} \gets \max_{\bx\in X} |\bx | \pcskipln\\
			\pclinecomment{Match Records} \\
			\pcfor j = 1, \dots, n_{max} \pcdo \\
			\t	\pcfor k = 1, \dots, m \pcdo \label{lin:match_loop_V}\\
			\t	\t 	\pcif \mathsf{matched}^{Y}[k] = \top \pcthen \pccontinue \\
			\t	\t	\pcfor i = 1, \dots, n \pcdo \\
			\t	\t	\t	\pcif \mathsf{matched}^X[i] = \top \lor |\bx_i| < j \pcthen \pccontinue\\
			\t	\t	\t	\pcfor \ell = 1, \dots, |\by_i| \pcdo \\
			\t	\t	\t	\t	\pcif \bx_i[j] = \by_k[\ell] \pcthen \label{lin:match_common_uid} \\
			\t	\t	\t	\t	\t	\uid \sample \calG \setminus \UID \\
			\t	\t	\t	\t	\t	\UID \gets \UID \cup \{\uid\} \\
			\t	\t	\t	\t	\t	\MX[\uid] \gets \bx_i \\
			\t	\t	\t	\t	\t	\MY[\uid] \gets \by_k \\
			\t	\t	\t	\t	\t	\mathsf{matched}^X[i] \gets \top; \;\mathsf{matched}^Y[k] \gets \top \pcskipln\\
			\pclinecomment{Assign uids to unmatched records} \\
			\pcfor i = 1, \dots, n \\
			\t 	\pcif \mathsf{matched}^X[i] = \bot \pcthen \label{lin:match_unmatched_C_uid} \\
			\t	\t	\uid \sample \calG \setminus \UID \\
			\t	\t	\UID \gets \UID \cup \{\uid\} \\
			\t	\t	\MX[\uid] \gets \bx_i \\
			\t	\t	\MY[\uid] \gets \bot \\
			\pcfor i = 1, \dots, m \\
			\t 	\pcif \mathsf{matched}^Y[i] = \bot \pcthen \label{lin:match_unmatched_P_uid} \\
			\t	\t	\uid \sample \calG \setminus \UID \\
			\t	\t	\UID \gets \UID \cup \{\uid\} \\
			\t	\t	\MX[\uid] \gets \bot \\
			\t	\t	\MY[\uid] \gets \by_i \\
			\pcreturn \UID, \MX, \MY
		}
	\end{pchstack}
	\caption{Record matching logic used in MK-PrivateID. \label{fig:match_logic}}
\end{figure}
