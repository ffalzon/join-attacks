
\section{Applications to Private Record Matching}\label{sec:PSUCA_to_matching}
In this section, we demonstrate how the $\PSUCAattack{}$ attack can be applied to the functionality of Meta's PrivateID protocol and (with some additional assumptions) to the $\calF_{\MKPM}$ functionality formalized in Figure~\ref{sec:prel_leakage}.



% Clearly, we have $|\UID| = |X \cup Y|$ for any two sets $X$ and $Y$.
% We can therefore apply \PSUCAattack{} directly to SKPM 
% to recover $X \cap Y$ in at most $|X| + 1$ SKPM evaluations.
% Guo et al.~\cite{Guo22} have already examined PrivateID in the context of their intersection recovery attack on \PSICA{},
% where they recover $X \cap Y$ in at most $|X|$ protocol invocations.
% However, they rely on the fact that PrivateID leaks $|X \cap Y|$ during the protocol execution, 
% while our attack relies on the functionality output alone.

% \subsection{MK-PrivateID}
% Meta's MK-PrivateID protocol~\cite{MPMC} implements the Multi-Key Private Matching (MKPM) functionality we defined in \cref{sec:prel_leakage}.
% We show in this section that \PSUCAattack{} can be applied to MKPM to 
% learn which records in the target set contain an identifier that also occurs in the victim set.
% This corresponds the \emph{Matchable Record Recovery} goal we formalized in \cref{sec:MRR_goal}.
% Recall that the attacker is given a set of records \setT{}, the target set, and can evaluate $\MKPM(\setT', \setV)$
% for arbitrarily many inputs $\setT'$, while the victim set \setV{} remains static.
% The adversary's goal is to determine the set $\setT \sqcap \setV = \{t \in \setT \setdsc \exists v \in \setV\; \exists j, \ell \in \N : t[j] = v[\ell]\}$.

% Similar to its single-key counterpart SKPM, 
% MKPM outputs a set $\UID$. However, instead of assigning a common uid to two identical records it matches records
% using a matching logic (see \cref{fig:match_logic}) and assigns a common uid to pairs of matching records,
% as well as a separate uid to every unmatched record in \setT{} and \setV{}.
% Thus, taking $|\UID|$ as the the union cardinality to carry out \PSUCAattack{} seems to be a natural approach 
% to identify matching records in \setT{}.
 
% Recall that the \PSUCAattack{} attack relies on the observation that $|X \cap Y| = |X_1 \cap Y| + |X_2 \cap Y|$,
% where $X$ and $Y$ are arbitrary sets and $X_1, X_2$ form a partition of $X$.
% Applying \cref{eqn:union_intersect_cardinalities}, this is equivalent to $|X \cup Y| = |X_1 \cup Y| + |X_2 \cup Y| - |Y|$.
% Translating this to the multi-key setting, let $\setX \subseteq \setT$ and let $\setX_1, \setX_2$ be a partition of \setX{}.
% Moreover, let \UID{}, $\UID_1$, and $\UID_2$ result from evaluating $\MKPM(\setX, \setV)$ and $\MKPM(\setX_i, \setV)$ for $i \in \{1,2\}$ respectively.
% Then, the following relation needs to hold:
% \begin{equation}
% 	\label{eqn:MKPM_PSUCA_condition}
% 	|\UID| = |\UID_1| + |\UID_2| - |\setV|
% \end{equation}

% Unfortunately, this does not hold for general inputs for two reasons.
% First, as we elaborated in \cref{sec:MRR_goal}, the MKPM functionality shuffles the inputs before 
% evaluating the matching logic on them. 
% As a result, the record matching logic does not consistently match the same number of records in different protocol runs for some fixed inputs,
% i.e., different evaluations of \MKPM{} with the same inputs result in \UID{} sets with different cardinalities.
% And second, the matching logic violates \cref{eqn:MKPM_PSUCA_condition} even in cases where shuffling the inputs has no effect on the former.

% Consider the situation depicted in \cref{fig:MPMK_PSUCA_counterexample}.
% On the left, we show an example of a target set \setT{} and victim set \setV{}, 
% where two records in the target set share an identifier with the same record in the victim set.
% We call this a \emph{many-to-one relation}.
% Recall that the matching logic uses the order of identifiers in \setT{} as priorities to resolve such many-to-one relations.
% That is, it matches the second target record with the victim record, since it shares its first identifier $\id_3$ with the victim record,
% as opposed to the first target record, which shares its second identifier with the victim record. The latter remains unmatched.
% The resulting set \UID{} therefore contains two elements: 
% one uid for the two matched records and one for the unmatched first target record.
% On the right, we show a partition of \setT{}, matched against the same victim set \setV{} (in two separate protocol invocations).
% Now isolated and lacking competition from the other record, both target records are matched.
% The resulting sets $\UID_1$ and $\UID_2$ therefore both contain one uid.
% That is, we have $|\UID| = |\UID_1| + |\UID_2| \neq |\UID_1| + |\UID_2| - |\setV|$, which violates the requirement mentioned above.

% \begin{figure}
% 	\centering
% 	{\def\linecorr{-.4pt}
% 	\def\rowspace{\linecorr}
% 	\def\colspace{1.2cm}
% 	\def\setspace{5cm}
% 	\def\setvertspace{.5cm}
% 	\def\minwidthid{.6cm}
% 	\def\blockminheight{1.3em}
% 	\begin{tikzpicture}
% 		[block/.style={draw,minimum width=#1, minimum height=\blockminheight,font={\tiny}},
% 		%block/.default=10em,high/.style={minimum height=3em},auto,
% 		block/.default=10em,high/.style={},auto,
% 		node distance=0, % initially 1cm
% 		>=Stealth]
% 		%node distance=5em,auto]
% 		% Nodes
% 		\node[block=\minwidthid,fill=trow-dark] (alice1) {$\id_1$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of alice1] (alice2) {$\id_2$};

% 		\node[block=\minwidthid,fill=trow-light, below=\rowspace of alice1] (bob1) {$\id_3$};
% 		\node[block=\minwidthid,fill=trow-light, right=\linecorr of bob1] (bob2) {$\id_4$};

% 		\coordinate (mid) at ($(alice2)!0.5!(bob2)$);

% 		\node[block=\minwidthid,fill=trow-dark, right=\colspace of mid] (vic1) {$\id_3$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vic1] (vic2) {$\id_2$};

% 		\coordinate (right-center) at ([xshift=(\setspace)]mid);


% 		\node[block=\minwidthid,fill=trow-dark, above=\setvertspace of right-center] (alicesub1) {$\id_1$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of alicesub1] (alicesub2) {$\id_2$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\colspace of alicesub2] (vicsub1) {$\id_3$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vicsub1] (vicsub2) {$\id_2$};

% 		\node[block=\minwidthid,fill=trow-dark, below=\setvertspace of right-center] (bobsub1) {$\id_3$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of bobsub1] (bobsub2) {$\id_4$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\colspace of bobsub2] (vicsub3) {$\id_3$};
% 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vicsub3] (vicsub4) {$\id_2$};

% 		% Connections
% 		\draw[dashed] (alice2) to (vic1);
% 		\draw (bob2) to (vic1);

% 		\draw (alicesub2) to (vicsub1);
% 		\draw (bobsub2) to (vicsub3);

% 		% \labels and descriptions
% 		\coordinate (center1) at ($(alice2.south east)!0.5!(vic1.west)$);
% 		\coordinate (center2) at ($(alicesub2.east)!0.5!(vicsub1.west)$);
% 		\coordinate (center3) at ($(bobsub2.east)!0.5!(vicsub3.west)$);

% 		\node[above=.3cm of alice1.east] (Tlabel) {\tiny$\setT$};
% 		\node[above=.3cm of vic1.east] (Vlabel1) {\tiny$\setV$};
% 		\node[below=.6cm of center1] (UIDlabel) {\tiny$|\UID| = 2$};
		
% 		\node[above=.3cm of alicesub1.east] (Tlabel2) {\tiny$\setT_1$};
% 		\node[above=.3cm of vicsub1.east] (Vlabel2) {\tiny$\setV$};
% 		\node[below=.3cm of center2] (UIDlabel1) {\tiny$|\UID_1| = 1$};
		
% 		\node[above=.3cm of bobsub1.east] (Tlabel3) {\tiny$\setT_2$};
% 		\node[above=.3cm of vicsub3.east] (Vlabel3) {\tiny$\setV$};
% 		\node[below=.3cm of center3] (UIDlabel2) {\tiny$|\UID_2| = 1$};
% 	\end{tikzpicture}}
% 	\caption{Example of a target set \setT{} and victim set \setV, where \PSUCAattack{} cannot be applied.
% 	Lines between records indicate potential matches based on matching identifiers. 
% 	Solid lines denote the matched records chosen by the matching logic.
% 	Clearly, $|\UID| \neq |\UID_1| + |\UID_2| - |\setV|$.}
% 	\label{fig:MPMK_PSUCA_counterexample}
% \end{figure}
% To avoid such cases, we formalize a restriction on the input sets that 
% -- if satisfied -- allows us to carry out the attack.
% Conveniently, the opposite case, where one record in the target set shares identifiers with multiple records in the victim set,
% does not lead to such problems.
% It therefore suffices to exclude many-to-one relations.

% \begin{definition}[Isolated Set]\label{def:isolated_set}
% 	Let \setX{} and \setY{} be two sets of records $\setX, \setY \subseteq \Ispace{}^{\leq \lambda}$ for some $\lambda\in\N$.
% 	We say \setX{} is \emph{$\setY$-isolated}, 
% 	if for all $v\in \setY$ we have $|\{t \in \setX \setdsc \exists i, j. \; t[i] = v[j]\}| \leq 1$.
% \end{definition}

% This additional constraint on the protocol inputs excludes some realistic scenarios.
% For instance, if the sets contain IP addresses
% -- IPv4 addresses behind a Network Address Translation (NAT) device in particular --
% such many-to-one relations are likely to occur, as users in the same local network share an address.
% However, this does not exclude the scenarios outlined in \cref{sec:threat_model},
% where the adversary chooses a specific range of identifiers as its target set, 
% such as all phone numbers of a certain area code or all email addresses belonging to some domain.
% Furthermore, scenarios where users possess multiple identifiers of some type,
% e.g., a private and a work email address, 
% but do not share them with other people, are still admitted as well, 
% provided that each user's identifiers only occur in at most one record in the target set.
% \cref{def:isolated_set} conveniently resolves both issues outlined above,
% which we prove in the following two lemmas.

% \begin{lemma}
% 	\label{lem:set_isolation_determinism}
% 	Let $\setX, \setY \subseteq \Ispace{}^{\leq \lambda}$ be two sets of records. 
% 	If \setX{} is \setY-isolated, 
% 	the cardinality of $\UID$ output by $\MKPM(\setX, \setY)$ (\cref{fig:MKPM}) is consistent across multiple evaluations.
% \end{lemma}
% \begin{proof}
% 	For any $x \in \setX$, let $\setY_x$ denote the records of \setY{} that share at least one identifier with $x$,
% 	i.e., $\setY_x := \{y \in \setY \setdsc \exists i, j \in \N : x[i] = y[j]\}$.
% 	If \setX{} is $\setY$-isolated, we have that $\setY_x \cap \setY_{x'} = \emptyset$ for all $x, x' \in \setX$ with $x \neq x'$. 
% 	Therefore, there exist no two records in \setX{} that could be matched with the same record in \setY{}.
	
% 	We first consider sets $\setY_x$ that are not empty.
% 	Since $x$ can only be matched with some $y \in \setY_x$ and all $y \in \setY_x$ can only be matched with $x$,
% 	\match{} (\cref{fig:match_logic}) will match $x$ with exactly one $y_x \in \setY_x$,
% 	which are assigned the same uid (line~\ref{lin:match_common_uid}).
% 	All other $y \in \setY_x$, i.e., $y \neq y_x$, will remain unmatched and are assigned their own uid (line~\ref{lin:match_unmatched_P_uid}).
% 	Furthermore, all $y \in \setY$ which do not belong to any $\setY_{x'}$ for any $x' \in \setX$ will also remain unmatched and are assigned their own uid (also line~\ref{lin:match_unmatched_P_uid}).
% 	Lastly, all $x\in\setX$ for which $\setY_x = \emptyset$ will remain unmatched and receive their own uid (line~\ref{lin:match_unmatched_C_uid}). 
	
% 	Thus, \UID{} contains one uid for each $y\in \setY$ and one uid for each unmatched $x\in \setX$, i.e.,
% 	$|\UID| = |\setY| + |\{x \in \setX \setdsc \setY_x = \emptyset\}|$.
% 	This is independent of the order of the records in \setX{} and \setY{} and
% 	thus also independent of the shuffling done before the matching step in \MKPM{}.
% 	Since \MKPM{} only uses randomness to shuffle the inputs, we have proven the lemma.
% \end{proof}

% \begin{lemma}
% 	\label{lem:set_isolation_inference}
% 	Let \setX{} and $\setY \subseteq \Ispace{}^{\leq \lambda}$ be two sets of records and let $\setX_1$ and $\setX_2$
% 	be a partition of $\setX$. 
% 	Moreover, let $(\UID, \MC) \sample \MKPM(\setX, \setV)$ and $(\UID_i, M_{C,i}) \sample \MKPM(\setX_i, \setV)$ for $i \in \{1,2\}$.
% 	If $\setX$ is \setY-isolated, we have $|\UID| = |\UID_1| + |\UID_2| - |\setY|$.
% \end{lemma}
% \begin{proof}
% 	We show this by induction on $|\setX_1|$.
% 	If $|\setX_1| = 0$ all records of $\setY$ are unmatched and, thus, $|\UID_1| = |Y|$.
% 	Note that $\setX_2 = \setX$ and thus we have $|\UID| = |\UID_2| = |\UID_2| + |\UID_1| - |Y|$.
% 	In the first equality, we use \cref{lem:set_isolation_determinism}. 

% 	Assume $|\setX_1| = n_1$ for some $n_1 > 0$ and $|\UID| = |\UID_1| + |\UID_2| - |\setY|$.
% 	Since $\setX_1$ and $\setX_2$ form a partition of $\setX$, we must move a record from $\setX_2$ to $\setX_1$
% 	to achieve $|\setX_1| = n_1+1$. Note that $|\UID|$ remains unchanged due to \cref{lem:set_isolation_determinism}.
% 	Let $x \in \setX_2$ and let $\setX'_1 := \setX_1 \cup \{x\}$ and $\setX'_2 := \setX_2 \setminus \{x\}$.
% 	Moreover, let $\UID'_1$ and $\UID'_2$ be the sets of UIDs resulting from evaluating $\MKPM(\setX'_1, \setY)$ and $\MKPM(\setX'_2, \setY)$. 
% 	We distinguish two cases.
% 	If no identifier of $x$ occurs in $\setY$, $x$ was assigned its own UID.
% 	Therefore, $|\UID'_1| = |\UID_1| + 1$ and $|\UID'_2| = |\UID_2| - 1$, which implies the claim.
	
% 	For the second case, assume $x$ shares some identifiers with $n^*$ records of $\setY$.
% 	Call this set $\setY_x$.
% 	Since \setX{} is \setY-isolated, all records $y \in \setY_x$ only share identifiers with $x$,
% 	but no other $x'\in \setX_2$.
% 	Thus, $x$ is matched with some $y^* \in \setY_x$,
% 	i.e., $x$ and $y^*$ are assigned the same $\uid \in \UID_2$.
% 	After removing $x$ from $\setX_2$, $y^*$ will still be assigned some $\uid' \in \UID'_2$, 
% 	which it does not share with any $x' \in \setX'_2$, again since $\setX$ is \setY-isolated. 
% 	Therefore, $|\UID_2| = |\UID'_2|$. 
% 	Similarly, since $x\not\in \setX_1$, no $y\in \setY_x$ and $x' \in \setX_1$ are assigned the same $\uid \in \UID_1$.
% 	By the definition of $\setY_x$ and since \setX{} is \setY-isolated, $x$ will be assigned the same $\uid\in \UID'_1$
% 	as some $y\in\setY_x$ after being added to $\setX_1$, implying $|\UID_1| = |\UID'_1|$.
% 	The claim then follows trivially.
% \end{proof}

% With the necessary properties of isolated input sets established, we can assert the correctness of our adaptation:

% \begin{theorem}
% 	Let \setT{} and \setV{} be two sets of records.
% 	If \setT{} is \setV{}-isolated, then \\
% 	$\PSUCAattack^{\MKPM(\cdot, \setV)}(\setT)$ recovers $\setT \sqcap \setV$.
% \end{theorem}
% \begin{proof}
% 	Let \posSet{} and \negSet{} be the two sets output by $\PSUCAattack^{\MKPM(\cdot, \setV)}(\setT)$.
% 	Note all records of \setT{} are contained in some subset $\setT_c\subseteq \setT$ that will eventually reach line~\ref{lin:PSUCA_add_condition},
% 	since the attack only terminates once the priority queue is empty. 
% 	Therefore, every record of \setT{} is added to either \posSet{} or \negSet{}.
% 	For any $\setT_c$ reaching line~\ref{lin:PSUCA_add_condition} 
% 	we have that either (1) $k_c = |\setT_c|$ or (2) $k_c  = 0$ by the loop condition on line~\ref{lin:PSUCA_inner_while_condition}.
% 	Let $\UID_c$ result from evaluating $\MKPM(\setT_c, \setV)$.
% 	By \cref{eqn:union_intersect_cardinalities} and \cref{lem:set_isolation_inference}, we have $k_c = |\setT_c| + |\setV| - |\UID_c|$.
% 	\begin{description}
% 		\item[Case (1)] If $k_c = |\setT_c|$, then we have $|\UID_c| = |\setV|$, i.e., all records of $\setT_c$ are matched. 
% 		Since records are only added to \posSet{} if this case applies, we have $\posSet \subseteq \setT \sqcap \setV$.
% 		\item[Case (2)] If $k_c = 0$, then $|\UID_c| = |\setT_c| + |\setV|$, i.e., no records of $\setT_c$ 
% 		were matched. Therefore, no record in $\setT_c$ shares any identifiers with any record in $\setV{}$.
% 		Since records are only added to \negSet{} if this case applies, we have $\negSet \subseteq \setT \setminus (\setT \sqcap \setV)$. 
% 	\end{description}
% 	We have therefore shown that \posSet{} only contains matchable records, \negSet{} only contains non-matchable records 
% 	and that every record in \setT{} is contained in either \posSet{} or \negSet{}.
% 	This proves the theorem.
% \end{proof}


% % \textbf{Time and Query Complexity.}
% % The adaptations described above merely consist of translating the notion of a set union cardinality to the multi-key scenario.
% % In particular, the elements of $X$ that lie in the intersection $X\cap Y$ are analogous
% % to the matchable records in \setT{} and \PSUCAattack{} behaves identically in the two settings.
% % It therefore also has the same worst-case time complexity and maximum number of MKPM evaluations.
% % Due to said correspondence between $X \cap Y$ and the matched records of \setT{}, 
% % we can expect the actual number of functionality evaluations for any given intersection size 
% % (or number of matchable records) to be similar.