% \begin{lemma}
% 	\label{lem:dictinfer_MR}
% 	Let \setX{} and \setY{} be two sets of records and let $(\leakX, \leakY) \sample \leak(\setX, \setY)$.
% 	Moreover, let $f_C: \Ispace{} \to \G$ be the hiding function sampled in \LMKPM{} to produce \leakX{} and \leakY.
% 	If $D$ is a dictionary mapping $f_C(\id)$ to \id{} for all $\id \in \Ispace{\setX}$,
% 	then $\dictInfer(D, \leakY)$ (\cref{fig:dict_infer}) produces a maximum reconstruction of \setY{} with respect to \setX{}.
% \end{lemma}
% \begin{proof}
% 	Let $\mathfrak{R}$ be the multiset produced by \dictInfer.
% 	Recall from \cref{sec:notation} that we consider different instantiations 
% 	of the same record in $\mathfrak{R}$ as distinct elements.
% 	Note that for each $y \in \leakY$ exactly one reconstructed record $r$
% 	is added to $\mathfrak{R}$.
% 	Let $d: \mathfrak{R} \to \leakY$ denote the function mapping these reconstructed records 
% 	to the corresponding $y$. Clearly, $d$ is a bijection.

% 	We now define an injective function $\varphi: \mathfrak{R} \to \setY$ and prove that it satisfies the three conditions for Maximum Set Reconstruction (\cref{def:max_recons}).
% 	For any record $r \in \mathfrak{R}$ let $(d_1, \dots, d_k)=d(r) \in \leakY$ and let
% 	$$\varphi(r) := (f_C^{-1}(d_1), \dots, f_C^{-1}(d_k))$$
	
% 	Note that $f_C^{-1}(d_j)$ exists for all $r$ and $j$, since $d(r) \in \leakY$ by definition.
% 	Moreover, since $f_C$ is injective, $f_C^{-1}$ is injective for elements in $f_C(\Ispace{})$.
% 	$\varphi$ is injective since $d$ and $f_C^{-1}$ are injective.
% 	We show the three properties from \cref{def:max_recons} separately:
% 	\begin{enumerate}
% 		\item Let $r\in \mathfrak{R}$, $k := |r|$ and $i \leq |r|$. 
% 		Moreover, let $(d_1, \dots, d_{k'}) = d(r)$ for some $k' \geq k$.
% 		By definition of $d$ and by construction of $r$ (line \ref{lin:substitute_add_id}), 
% 		there exists some $j^*\in[k']$ such that $r[i] = D[d_{j^*}]$.
% 		Suppose for a contradiction that $r[i] \not \in \varphi(r)$, that is,
% 		we have $r[i] \neq f_C^{-1}(d_j)$ for all $j \in [k']$.
% 		But since for all $j \in [k']$ with $d_j \in D$ we have $f_C^{-1}(d_j) = D[d_j]$,
% 		we also have that $r[i] \neq D[d_j]$, i.e., there is no $j$ such that $r[i] = D[d_j]$. 
% 		This is a direct contradiction to $r[i] = D[d_{j^*}]$.
% 		% However, if this holds, then the condition on line \ref{lin:substitute_membership_check} 
% 		% would not have been true for any $j\in[k']$ and thus $r[i]$ would not have been added, 
% 		% thus resulting in a contradiction. 
% 		\item Let $r\in \mathfrak{R}$ and $(d_1, \dots, d_{k'}) = d(r)$ for some $k' \in \N$.
% 		Let $\id \in \varphi(r)$, 
% 		i.e., there is some $i \in [k']$ such that $\id = f_C^{-1}(d_i)$.
% 		If $\id \in \Ispace{\setX}$, then by assumption we have $f_C(\id) \in D$ and $D[f_C(\id)] = \id$.
% 		Since $\id = f_C^{-1}(d_i)$, we have $f_C(\id) = f_C(f_C^{-1}(d_i)) = d_i$ 
% 		and thus $d_i \in D$. Therefore, the condition on line~\ref{lin:substitute_membership_check} is met and
% 		$D[d_i] = D[f_C(\id)] = \id$ is added to $r$.
% 		\item Holds trivially, since we have $\varphi(\mathfrak{R}) = \setY$ by the definition of $d$. 
% 	\end{enumerate}
% The lemma thus follows.
% \end{proof}

% \begin{lemma}
% 	For any target set \setT{} and victim set \setV{}, 
% 	$\toyattack^{\LMKPM(\cdot, \setV)}(\setT)$ from \cref{fig:toy_attack}
% 	produces a maximum reconstruction of \setV{} with respect to \setT{}.
% \end{lemma}
% \begin{proof}
% 	It is easy to see that the record $r$ constructed in lines \ref{lin:baseline_r_start}~-~\ref{lin:baseline_r_end} contains all identifiers from 
% 	$\Ispace{\setT}$ and therefore $\Ispace{\setT} = \Ispace{\setT'}$. 
% 	It therefore suffices to show that $\toyattack$ produces a maximum reconstruction of $\setV$ w.r.t. $\setT'$.
	
% 	Let $f_C$ be the identifier hiding function sampled during the invocation of 
% 	\LMKPM{} in line \ref{lin:baseline_eval},  
% 	let $D$ be the dictionary constructed in lines \ref{lin:baseline_D_start} and \ref{lin:baseline_D_end} 
% 	and let $k = |r|$.
% 	By definition of \LMKPM{}, we have $r_e = (f_C(r[1]), \dots, f_C(r[k]))$
% 	and therefore $D[f_C(r[i])] = D[r_e[i]] = r[i]$ for all $i \in [k]$.
% 	Since $r$ contains all identifiers from $\Ispace{\setT'}$, the claim follows from \cref{lem:dictinfer_MR}.
% \end{proof}

%%%%
\subsection{Proof of Correctness of $\recenumattack$}
\label{sec:recenumattack:correctness}
% \begin{proof}
% In order to prove the theorem we prove the following proposition. 
% The theorem follows directly from Proposition~\ref{thm:recenum_D} and \cref{lem:dictinfer_MR}.
% \begin{proposition}\label{thm:recenum_D}
% 	Let \setT{} and \setV{} be two sets of records and let
% 	$D$ be the dictionary constructed during an execution of $\recenumattack^{\LMKPM(\cdot, \setV)}(\setT)$ (\cref{fig:rec_enum_attack}).
% 	Moreover, let $f_C$ be the identifier hiding function sampled during the evaluation of \LMKPM{} in line~\ref{lin:recenum_evaluation} in \cref{fig:rec_enum_attack}. 
% 	We have $D[f_C(\id)] = \id$ for all $\id \in \Ispace{\setT}.$
% \end{proposition}
% \begin{proof} \textbf{of Proposition~\ref{thm:recenum_D}} 
% 	Let $\setT' = \{t'_0, \dots, t'_{n-1}\}$, where $t'_i$ denotes the altered target record constructed in 
% 	line~\ref{lin:recenum_t_prime} for $i \in \{0, \dots, n - 1\}$.
% 	We show that $D[f_C(\id)] = \id$ for all $\id \in \setT'$.
% 	Since $\Ispace{\setT} \subseteq \Ispace{\setT'}$, this implies the claim.
	
% 	We first show that $e_0 = f_C(\id_0)$ for the value $e_0$ defined on line~\ref{lin:assign_e0}.
% 	Note that the transformation of an index's binary representation to a sequence of $\id_0$ and $\id_1$
% 	in lines \ref{lin:idx_to_seq_bin_encode_start}~-~\ref{lin:idx_to_seq_bin_encode_end} of \IdxToSeq{}
% 	could produce two encodings that only contain one identifier, namely, $(\id_0)^\ell$ and $(\id_1)^\ell$
% 	for $i = 0$ and $i = 2^\ell - 1$ respectively.
% 	However, the latter is prevented by the condition on line~\ref{lin:seq_to_idx_tiebreak} and therefore
% 	\IdxToSeq{} only outputs one sequence where all identifiers are equal.
% 	Hence, there is only one record in $\setT'$ whose first $\ell$ identifiers all coincide,
% 	namely, $t'_0$ with encoding $(\id_0)^\ell$.
% 	Since $f_C$ is injective and the identifiers in records of $\setT'$ are not shuffled, 
% 	the latter also holds for $\leak_{\setT'}$.
% 	Therefore, $t^*_0 = (f_C(t'_0[1]), \dots, f_C(t'_0[\lambda + \ell]))$ (line~\ref{lin:recenum_t0}).
% 	Since $t'_0[1] = \id_0$, we have $e_0 = t^*_0[1] = f_C(t'_0[1]) = f_C(\id_0)$ (see line~\ref{lin:recenum_e0}).
	
% 	We now show that the attack correctly recovers indices from $\leak_{\setT'}$. 
% 	We have already established that $t^*_0$ is correctly matched with $t'_0$,
% 	as it's encoding is the only one containing only $\id_0$. 
% 	Any other encoding $s$ produced by \IdxToSeq{}
% 	either (a) is $(\id_1)^{\ell - 1} \ccat \id_2$ or (b) only
% 	contains the identifiers $\id_0$ and $\id_1$.
% 	\begin{description}
% 	\item[Case (a):] This case is only produced on input $i = 2^\ell - 1$ and the resulting vector of hidden identifiers in the 	
% 		 leakage is $(f_C(\id_1))^{\ell - 1} \ccat f_C(\id_2)$. 
% 		 This satisfies the condition on line~\ref{lin:seq_to_idx_tiebreak} of \SeqToIdx{}, 
% 		 which therefore yields the correct index $2^\ell - 1$.
% 	\item[Case (b):] In this case, the vector of hidden identifiers corresponding to $s$ in the leakage, which we denote
% 		$s^*:=(f_C(s[1]),\allowbreak\dots,f_C(s[\ell]))$, does not satisfy the condition on line~\ref{lin:seq_to_idx_tiebreak}, 
% 		since the only encoding that would do so is $(\id_1)^{\ell}$. 
% 		But this is never output by \IdxToSeq{}. 
% 		Therefore, $s^*$ is interpreted as a binary encoding, where every occurrence of $e_0$ 
% 		is interpreted as $0$ and every other identifier as $1$.
% 		The correctness of this recovery therefore follows from the fact that $e_0 = f_C(\id_0)$,
% 		which we established above.
% 	\end{description}
	
% 	By the definition of \LMKPM{}, we have $t^*_i = (f_C(t'_i[1]), \dots, f_C(t'_i[\lambda+\ell]))$ for all $i \in \{0, \dots, n-1\}$.
% 	Since $\Ispace{\setT'} := \bigcup_{\substack{l}{t\in\setT'\\\id \in t}} \id$, 
% 	the claim holds by the construction of $D$ in lines~\ref{lin:recenum_D_start}~-~\ref{lin:recenum_D_end}.
% \end{proof}
	
% % \begin{proof}
% 	The theorem follows directly from \cref{thm:recenum_D} and \cref{lem:dictinfer_MR}.
% \end{proof}

\subsection{Proof of Correctness of $\snakeattack$}
\label{sec:snakeattack:correctness}


% \begin{proof}
% 	To prove the theorem, we prove the following proposition.
% 	The theorem follows directly from Proposition~\ref{thm:snake_D} and \cref{lem:dictinfer_MR}.
% \begin{proposition}
% 	\label{thm:snake_D}
% 	Let \setT{} and \setV{} be two sets of records and let $D$ be the substitution dictionary
% 	constructed during an invocation of $\snakeattack^{\LMKPM(\cdot, \setV)}(\setT)$.
% 	Moreover, let $f_C$ be the identifier hiding function sampled during the invocation of \leak{}
% 	in line~\ref{lin:snake_evaluation}.
% 	Then, we have $D[f_C(\id)] = \id$ for all $\id \in \Ispace{\setT}$.
% \end{proposition}
% \begin{proof} \textbf{of Proposition~\ref{thm:snake_D}}
% 	Let $\setT' := \{t'_1, \dots, t'_n\}$ where $t'_i$ is produced by \snakeencodeUnique{} in line~\ref{lin:snake_encode}
% 	and let $k' := |t'_i|$ for any $i\in [n]$\footnote{Recall that we assume that all records have the same length $\lambda$.
% 	Thus, $k' \in \{\lambda + 1, \lambda+2\}$}.
% 	We show that $D[f_C(\id)] = \id$ for all $\id \in \Ispace{\setT'}$.
% 	Since \snakeattack{} potentially adds fresh identifiers to records of \setT{}, but does not remove any, 
% 	we have $\Ispace{\setT}\subseteq\Ispace{\setT'}$, which implies the claim.
	
% 	Similar to the proof of \cref{thm:recenum_D}, we show that
% 	$t^*_i[j] = f_C(t'_i[j])$ for all $i\in[n]$ and all $j \in [k']$.
% 	The result then follows from the construction of $D$ in lines~\ref{lin:snake_D_start}~-~\ref{lin:snake_D_end}. 
% 	In particular, we will show that the linked list we create in \IdxToSeq{} is preserved in the leakage, 
% 	and that this linked list allows us to uniquely identify each record. 
% 	We show this by induction on $i$. 
% 	Let $j^*$ denote the index of a column whose identifiers are all unique (note that if such a column does not exist, it is created on line~\ref{lin:distinctIDs_j*}).

% 	For $i = 1$, observe that identifier $t_1[j^*]$ is not appended to any record in \snakeencodeUnique{}; 
% 	in other words, it is the only item in the linked list that doesn't have anything pointing to it.
% 	In contrast, for all $i' > 1$, identifier $t_{i'}[j^*]$ is appended to $t_{i'+1}$.
% 	$t'_1$ is therefore the only record in $\setT'$ whose $j^*$-th identifier is not contained in the last column, 
% 	i.e., $t'_1[j^*] \not \in \{t'_{i'}[k'] \setdsc i'\in[n]\}$.
% 	By the definition of $\LMKPM$, this property is preserved in the leakage $\leak_{\setT'}$.
% 	That is, the corresponding record in the leakage $h = (f_C(t'_1[1]), \dots, f_C(t'_1[k']))$
% 	is the only record in $\leak_{\setT'}$ such that such that $h[j^*]\not\in\{h_{i'}[k'] \setdsc i' \in [n]\}$.
% 	In line~\ref{lin:snake_recover_c} in \snakerecoverUnique{} we pick $h_c := h$.
% 	Thus, for all $j \in [k']$ we have that $h_c[j] = f_C(t'_1[j])$
% 	and, therefore  $t^*_1[j] = h_c[j] = f_C(t'_1[j])$, where the first equality follows from line~\ref{lin:snake_recover_assign_t_star}.

% 	Now assume that for some $i < n$ we have $t^*_i[j] = f_C(t'_i[j])$ for all $j \in [k']$. 
% 	We show that there is a unique record which $t'_i[k']$ is pointing to (that has not been traversed by the previous items in the linked list), 
% 	and that, once again this property is preserved in the leakage allowing for unique identification of the record.
% 	By construction in \snakeencodeUnique{}, we have $t'_{i+1}[j^*] = t'_i[k']$.
% 	Since all identifiers in the $j^*$-th column are distinct, 
% 	$t'_{i+1}$ is the only record in $\setT'$ that satisfies this condition.
% 	As before, since $f_C$ is injective, the corresponding record in the leakage 
% 	$h = (f_C(t'_{i+1}[1]), \dots, f_C(t'_{i+1}[k']))$
% 	is the only record that satisfies $h[j^*] = t^*_i[k']$.
% 	Moreover, all hidden identifiers in the $j^*$-th column of $\leak_{\setT'}$	are distinct. % $t'_{i+1}$ is the only record in $\setT'$
% 	Thus, the dictionary \loc{} in \SeqToIdx{} contains exactly the $n$ keys $\{f_C(t'_{i'}[j^*]) \setdsc i' \in [n]\} = \{f_C(t^*_{i'}[j^*]) \setdsc i' \in [n]\}$,
% 	which are mapped as $\loc[f_C(t'_{i'}[j^*])] = i'$.
% 	In line~\ref{lin:snake_recover_assign_t_star}, we pick $t^*_{i+1} := h_c$ for $c = \loc[t^*_i[k']]$, 
% 	implying $t^*_{i+1}[j^*] = t^*_i[k']$ and, thus, $t^*_{i+1} = h$.
% 	We therefore have $t^*_{i+1}[j] = h[j] = f_C(t'_{i+1}[j])$ for all $j \in [k']$.
% \end{proof}

% 	The statement follows from \cref{thm:snake_D} and \cref{lem:dictinfer_MR}.
% \end{proof}
