\section{Experimental Evaluation}\label{sec:evaluation}

\heading{Experimental Setup.}
We implemented our attacks in Python~3.12.3 and ran the experiments on a 64-core AMD EPYC 7742 2.25\,GHz processor with 512\,GB memory. Each experiment was executed on a single physical core, and our test suite (which ran 40–50 experiments in parallel) did not exceed 10\,GB of memory.

We simulated the protocol on the same node on which we executed the attacks. Our reported time measurements exclude network latencies and functionality evaluation; the reported times thus reflect only the time required to carry out the attack. Each experiment was repeated $50$ times, and we report average runtime and query counts across runs.

\subsection{Data Generation} 

Our attacks are largely data-independent. Thus, for ethical reasons, we evaluated the attacks using synthetic data, which also allowed precise control over the test data parameters. We note that Falzon and Tang~\cite{USENIX:FalTan25} also used synthetic datasets in their evaluation.


\heading{PSU and PSU-CA.} $\calF_{\PSU}$ and $\calF_{\PSUCA}$ operate on sets of elements. Given the high efficiency of our $\PSUattack$ attack, we tested it with a recovery set of size $m = 10^6$. For the $\calF_{\PSUCA}$ attack, we used $m = 10^4$.
The target set size $n$ ranged from $50\%$ to $150\%$ of $m$ in $10\%$ increments.

We varied the intersection size as a fraction of $T$,
\[
    \rho := |T \cap Y| / n,
\]
from $0\%$ to $100\%$ in $10\%$ increments. When $n > m$, we only measured up to the largest feasible fraction that is a multiple of $10\%$.

To generate $T$, we sampled $n$ elements without replacement from the interval $[0, 2n)$. To construct $Y$, we first sampled $\rho n$ elements from $T$ and then sampled the remaining $m - \rho n$ elements without replacement from the interval $[2n, 2(n + m - \rho n))$.


\heading{MKPM and L-MKPM.} 
The $\calF_{\MKPM}$ and $\calF_{\LMKPM}$ functionalities take as input sets of records. Each record in our datasets consist of an email address, a phone number, an IP address, and an advertising ID (AAID).\footnote{This set of values follows Meta's Developer Reference: \url{https://developers.facebook.com/docs/private-computation/reference/}} The first three values were generated using the \texttt{Faker} Python package, while the AAID was a randomly sampled string of 32 hexadecimal digits.

For a given pair of target and recovery sets $T$ and $Y$, we define the match rate $\eta$ as the fraction of all values in $T$ that also appear in $Y$, including multiple occurrences of the same value. Specifically, for $N := \sum_{\bt \in T} |\bt|$, we have:
\[
\eta := \left(\sum_{\bt \in T} \sum_{v \in \bt} \mathbbold{1}\{v\in \Ispace[Y]\}\right)/ N.
\]
While $\eta$ describes the overall match rate of $T$, the match rates for individual columns of $T$ may vary.

In our experiments with $\calF_{\MKPM}$ and $\calF_{\LMKPM}$, the recovery set contained $m = 10^4$ records. We varied $\eta$ from $0\%$ to $100\%$ in $10\%$ increments. When $n > m$, we measured up to the largest feasible fraction divisible by $10\%$. The target set size $n$ ranged from $50\%$ to $150\%$ of $m$, increasing in $10\%$ increments.


\begin{figure}
	\centering
    \subfloat[\label{fig:plot_PSU_large_time:left}]{
    \input{plots/PSU_1M/time_mr.tex}
    }
    \hspace{1mm}\subfloat[\label{fig:plot_PSU_large_time:right}]{
    \input{plots/PSU_1M/time_n.tex}
    }
	\caption{Runtime of $\PSUattack{}$ for a recovery set of size $|Y| = 10^6$. 
	(a) Runtimes vs.\ intersection ratio $\rho$ for target set sizes \ref{legend:PSU_timeTlow} $0.5 \cdot 10^6$, \ref{legend:PSU_timeTmid} $10^6$, and \ref{legend:PSU_timeThigh} $1.5 \cdot 10^6$.
	(b) Runtimes vs.\ target set size $|T|$ for intersection ratios \ref{legend:psu_time2} $40\%$, \ref{legend:psu_time6} $60\%$, and \ref{legend:psu_time10} $80\%$.}
	\label{fig:plot_PSU_large_time}
\end{figure}



\subsection{PSU Attack Evaluation}
Overall, the $\PSUattack$ attack (Figure~\ref{fig:PSU_attack}) is very efficient, as shown in Figure~\ref{fig:plot_PSU_large_time}.
On a large recovery set with $m = 10^6$ elements, runtimes range from \SI{0.74}{\second} to \SI{3.13}{\second}, since the attack performs only set union and difference operations.
For comparison, on the smaller recovery set with $m = 10^4$ elements (used for the other attacks), runtimes range from \SI{4}{\milli\second} to \SI{9}{\milli\second}.

Figure~\ref{fig:plot_PSU_large_time:left} shows that the intersection ratio $\rho$ has a mild impact on runtime, with larger $\rho$ yielding slightly faster executions.
This matches Python's set-difference implementation, which is linear in the size of the first operand.
As $\rho$ increases, the number of elements shared between $T$ and $Y$ increases, resulting in a smaller $Z = T \cup Y$; this makes $Z \setminus T$ more efficient to compute (line~\ref{lin:PSUDiff_Z-X}, Figure~\ref{fig:PSU_attack}).
Likewise, smaller $Z_1 = T_1 \cup Y$ and $Z_2 = T_2 \cup Y$ lead to a faster computation of $Z_1 \cup Z_2$.

Figure~\ref{fig:plot_PSU_large_time:right} plots runtimes against the target set size $|T|$.
As expected, runtimes grow approximately linearly in $|T|$.
We observe runtime spikes between $|T| = 8 \cdot 10^5$ and $9 \cdot 10^5$ for $\rho = 0.4$ and between $|T| = 10^6$ and $1.1 \cdot 10^6$ for $\rho \in \{0.6, 0.8\}$; this is likely caused by the working set exceeding the processor’s L3 cache.

\subsection{Search Tree Attacks Evaluation}
We now evaluate our two search tree attacks: $\PSUCAattack$ (Figure~\ref{fig:PSUCA_attack}) and $\mkpsiattack$ (Figure~\ref{fig:MKPSIattack}). We used the same set sizes across experiments for both attacks.
We plot the number of queries for both attacks in Figures~\ref{fig:plot_ST_queries_over_n} and \ref{fig:plot_ST_queries_over_mr},
and their runtimes in Figure~\ref{fig:st_time_all}.

The time and query measurements of the two attacks are largely symmetric with respect to the intersection ratio and match rate.
Specifically, for any $\varepsilon$, measurements for experiments with $\rho, \eta \in \{\varepsilon, 1-\varepsilon\}$ are nearly identical. We therefore only report measurements for $\rho, \eta \leq 0.5$ in this subsection. This symmetry follows from the number of queries performed by the attacks:
isolating a small set of matched elements from a large set of unmatched ones (small intersection ratio) is equivalent to isolating a large set of matched elements from a small set of unmatched ones (large intersection ratio).
The expected number of queries is the same in both cases.


\begin{figure}
	\centering
    \subfloat[\PSUCAattack\label{fig:plot_ST_queries_over_nt:left}]{
	\input{plots/PSUCA/queries_n.tex}
    }
    \subfloat[\mkpsiattack\label{fig:plot_ST_queries_over_n:right}]{
	\mkpsiQueryNPlot{}{measurements/leakage_attacks/mkpsi_queries_over_n/V10000}
    }
	\caption{The number of queries required by the (a) $\PSUCAattack${} and (b) $\mkpsiattack$ plotted against the target set size 
	for intersection ratios $\rho$ and match rates $\eta$: \ref{legend:PSUCA_qn_n_0}~$0\%$, \ref{legend:PSUCA_qn_n_1}~$10\%$, \ref{legend:PSUCA_qn_n_2}~$20\%$, \ref{legend:PSUCA_qn_n_3}~$30\%$, \ref{legend:PSUCA_qn_n_4}~$40\%$ and \ref{legend:PSUCA_qn_n_5}~$50\%$.
	The experiment was run with $|Y| = 10^4$.}\label{fig:plot_ST_queries_over_n}
\end{figure}



\subsubsection{Queries.}\label{sec:st-queries}
Figures~\ref{fig:plot_ST_queries_over_n} and \ref{fig:plot_ST_queries_over_mr} (Appendix~\ref{ap:evaluation}) plot the number of queries required by each attack as functions of the target set size, and intersection ratio $\rho$ and match rate $\eta$, respectively.
We observe that values of $\rho$ and $\eta$ near $0.5$ incur the highest percentages: $36\%$ occurs for $\rho, \eta \in \{0.1, 0.9\}$ and $73\%$ for $\rho = \eta = 0.5$, and these percentages are consistent across target set sizes. Figure~\ref{fig:plot_ST_queries_over_n} also shows that the absolute number of queries grows linearly with the target set size, matching the linear theoretical bounds.

Both attacks make almost the same number of queries, despite \mkpsiattack{} having a stricter early-termination criterion. For any experiment, their difference never exceeds $0.5\%$ of the theoretical upper bound, with \mkpsiattack{} slightly higher. The only exception is when $\rho$ or $\eta$ is $0$ or $1$: then \PSUCAattack{} always uses three queries, while \mkpsiattack{} uses only one, due to the two extra queries \PSUCAattack{} needs to determine $|Y|$.

The heuristic used to choose which child to follow during path traversal, and which subset to process next after termination, has only a minimal impact on the number of queries. This is expected, as the attacks terminate only once all subsets in the priority queue have been processed. The number of subsets in the queue depends solely on the (random) partitioning, not on the heuristic. We therefore report only the measurements for the positive heuristics $p_{\PSICA}^{+}$ and $p_{MK}^{+}$ in this section.


\begin{figure}[t]
  \centering
  \subfloat[\PSUCAattack]{
    \mkpsiTimeMRPlot{}{$\rho$}{time [ms]}{measurements/PSU/PSUCA_time_over_mr/V10000}
    \label{fig:st_time_psuca_mr}
  }
  \subfloat[\mkpsiattack]{
    \mkpsiTimeMRPlot{}{$\eta$}{}{measurements/leakage_attacks/mkpsi_time_over_MR/V10000}
    \label{fig:st_time_mkpsi_mr}
  }\\[-0.4em]
  \subfloat[\PSUCAattack]{
    \mkpsiTimeNPlot{}{$n = |T|$}{time [ms]}{measurements/PSU/PSUCA_time_over_n/V10000}
    \label{fig:st_time_psuca_n}
  }
  \subfloat[\mkpsiattack]{
    \mkpsiTimeNPlot{}{$n = |T|$}{}{measurements/leakage_attacks/mkpsi_time_over_n/V10000}
    \label{fig:st_time_mkpsi_n}
  }
  \caption{Runtimes of the $\PSUCAattack$ and $\mkpsiattack$ attacks.
  (a,b) Runtimes plotted against the intersection ratio $\rho$ and match rate $\eta$ for target set sizes
  \ref{legend:mkpsi_timeTlow}~$0.5\cdot 10^4$,
  \ref{legend:mkpsi_timeTmid}~$10^4$,
  \ref{legend:mkpsi_timeThigh}~$1.5\cdot 10^4$.
  (c,d) Runtimes plotted against the target set size $n = |T|$ for intersection ratios $\rho$ and match rates $\eta$:
  \ref{legend:mkpsi_time0}~$0\%$,
  \ref{legend:mkpsi_time1}~$10\%$,
  \ref{legend:mkpsi_time2}~$20\%$,
  \ref{legend:mkpsi_time3}~$30\%$,
  \ref{legend:mkpsi_time4}~$40\%$,
  \ref{legend:mkpsi_time5}~$50\%$.}
  \label{fig:st_time_all}
\end{figure}


\subsubsection{Runtime.} Figure~\ref{fig:st_time_all} shows the runtimes of both attacks as a function of the intersection ratio $\rho$ or match rate $\eta$ and the target set size.
\PSUCAattack{} runs in \SIrange{3}{130}{\milli\second}, depending on the parameters.
\mkpsiattack{} is markedly slower, with runtimes from \SI{145}{\milli\second} for $\eta = 0$ and $n = 0.5 \cdot 10^4$
up to \SI{177}{\second} for $\eta = 0.5$ and $n = 1.5 \cdot 10^4$.

Although the two attacks issue almost the same number of queries,
\mkpsiattack{} is more than three orders of magnitude slower than \PSUCAattack. We attribute this to the computation of \colCA{}, which is recomputed after every query and scans all values in $\hYone$ and the current target subset.

Figures~\ref{fig:st_time_psuca_mr} and \ref{fig:st_time_mkpsi_mr} demonstrate that runtimes are significantly influenced by $\rho$ and $\eta$, peaking for values near $0.5$, which aligns with our prior observation that this regime involves the highest query counts.
Meanwhile, Figures~\ref{fig:st_time_psuca_n} and \ref{fig:st_time_mkpsi_n} indicate that runtimes for both attacks scale roughly linearly with target set size, despite theoretical complexities of \bigO{n \log n} for \PSUCAattack{} and \bigO{\lambda n(\log n + m)} for \mkpsiattack. We believe the logarithmic overhead from priority-queue operations only becomes noticeable in larger data sets.

In Appendix~\ref{ap:evaluation}, we present additional experiments conducted under limited query budgets. Our findings reveal that adversaries can reconstruct substantial information even with a reduced number of protocol invocations.

\subsection{L-MKPM Attack Evaluation}
The maximum set reconstruction attacks presented in section~\ref{sec:lmkpm-attacks}---$\baselineattack{}$, $\recenumattack{}$, and $\snakeattack{}$---all require just a single protocol execution. 
We only discuss the runtime measurements, 
which are plotted against the match rate $\eta$ and target set size $n$ in Figure~\ref{fig:leakage_attacks_time_plot}.

The attacks are all highly efficient. $\baselineattack{}$ is the fastest, with runtimes from \SI{38}{\milli\second} ($n = 0.5 \cdot 10^4$) to \SI{112}{\milli\second} ($n = 1.5 \cdot 10^4$). \snakeattack{} is $1.5$--$2\times$ slower, ranging from \SI{66}{\milli\second} to \SI{214}{\milli\second}, due to simpler pre-processing but costlier post-processing. \recenumattack{} is the slowest, with runtimes from \SI{266}{\milli\second} to \SI{884}{\milli\second}, because its encoding and decoding operations involve prepending and inspecting $\log_2 n$ values per record.

Figure~\ref{fig:leakage_attacks_time_plot:left} shows that all three attack runtimes are largely independent of the match rate. This is consistent with theory since match rate affects only the reconstruction dictionary size. Figure~\ref{fig:leakage_attacks_time_plot:right} shows that $\baselineattack{}$ and $\snakeattack{}$ runtimes increase linearly with target set size, matching their theoretical time complexity. In contrast, \recenumattack{} incurs longer runtimes and steeper growth as $n$ increases.



\begin{figure}[t]
	\centering
    \subfloat[\label{fig:leakage_attacks_time_plot:left}]{
        \reconstructionTimePlot{}{$\eta$}{time [ms]}{max_V_match_fraction}{measurements/leakage_attacks/time_over_MR/V10000T10000.csv}{0.0, 0.5, 1}{-0.05}{1.05}
    }
    \subfloat[\label{fig:leakage_attacks_time_plot:right}]{
        \reconstructionTimePlot{}{$n=|T|$}{}{len_T}{measurements/leakage_attacks/time_over_n/V10000MR0.5.csv}{}{}{}
    }
	\caption{Runtime measurements of \ref{legend:baseline} $\baselineattack$, \ref{legend:recordenumeration} $\recenumattack$ and \ref{legend:snake} $\snakeattack$
	plotted against (a) the match rate $\eta$ and (b) the target set size.
	}\label{fig:leakage_attacks_time_plot}
\end{figure}


