\section{Value Intersection Recovery with $\calF_{\LMKPM}$}\label{sec:st-mkpm-attack}

We now leverage the additional leakage that $\calF_{\LMKPM}$ outputs to $\tP_1$ to mount stronger attacks. We adapt Guo et al.'s search tree approach~\cite{USENIX:GHLWJL22}, designed for $\calF_{\PSICA}$, to recover the values shared between the party inputs and achieve \emph{value intersection recovery} (Definition~\ref{def:VIR_goal}). 
%In the full version, we additionally show how to recover the multiplicities of each value.

For this attack, we restrict the adversary to using only subsets of its target set $T$ as input: it may submit any $T' \subseteq T$ but cannot append, split, or rearrange the values within records (this contrasts with Section~\ref{sec:lmkpm-attacks}, where the adversary can modify record contents by appending or reordering values). 
We assume all records in $T$ have equal length $\ell_{\rec} \in \NN$. 
The goal is to compute the intersection of values which we denote as $\posSet := \Ispace[T] \cap \Ispace[Y]$. Throughout the attack, we also construct a second set, $\negSet := \Ispace[T] \setminus \Ispace[Y]$, of values in $T$ that are not in $Y$. 

% Recall that the output of $\calF_{\LMKPM}(X;Y)$ to party $\tP_1$ is
% \[
% (\UID, \MX, \leak^1) = (\UID, \MX, (\hXone, \hYone)),
% \]
% where $\UID$ denotes the set of all assigned UIDs, $\MX$ is the local mapping from UIDs to records in $X$, and $(\hXone, \hYone)$ are the hidden, shuffled records of $X$ and $Y$, respectively. 


Our adapted attack starts by building a binary search tree $\calT$ over $T$ similar to the original attack~\cite{USENIX:GHLWJL22}. The root node corresponds to the entire target set $T$. Each node $v$ is labeled with a subset $v.\treeSet \subseteq T$. Its children $v_L \gets v.\treeLeftChild$ and $v_R \gets v.\treeRightChild$ form a disjoint partition of the parent:
$v_L.\treeSet \cup v_R.\treeSet = v.\treeSet$ and $v_L.\treeSet \cap v_R.\treeSet = \emptyset$.
We use a fixed, deterministic rule to compute the partition (e.g., by index into equal halves) and recurse until leaves are single records. 


Starting at the root, the adversary traverses $\calT$ in DFS order, selecting a node at each step and querying $\calF_{\LMKPM}(\cdot; Y)$ on that node’s associated subset of records. Let $X \gets v.\treeSet$ for a non-leaf node $v$, and $X_1 \gets v_L.\treeSet$, $X_2 \gets v_R.\treeSet$ be its children. In Guo et al.'s PSI-CA attack, querying a parent $X$ and one child $X_1$ suffices to infer the sibling’s output: from $|X \cap Y|$ and $|X_1 \cap Y|$ one immediately obtains $|X_2 \cap Y|$ without a third query.

Under $\calF_{\LMKPM}$, this sibling inference is not possible: each query generates UIDs with fresh randomness, so given $(\leakX{}, \leakY)$ and $(\leakX{1}, \leakY)$, one cannot derive $(\leakX{2}, \leakY)$. Instead of inferring the sibling’s full leakage, we switch to a metric for which the sibling’s value \emph{can} be inferred without an additional query---namely, the number of matched values \emph{per column} in $\leakX{}$ and $\leakX{1}$---and use this to guide the DFS traversal. Formally, this metric is defined as:
\begin{align*}
    \text{Col}&\text{CA}(\leakX{}, \leakY) \\
	&:= \left(\sum_{\bt\in\leakX{}}\mathbbm{1}\{\bt[1] \in \Ispace[\leakY]\}, \dots, \sum_{\bt\in\leakX{}}\mathbbm{1}\{\bt[\ell_{\rec}] \in \Ispace[\leakY]\}\right).
\end{align*}


We make the following important observations about \colCA:
\begin{proposition}
	\label{prop:mkpsi_equiv}
	For any two sets of records $X$ and $Y$, we have
	\begin{equation*}
		\colCA(\leakX{}, \leakY) = \colCA(X, Y).
	\end{equation*}
\end{proposition}
In words, because the hiding function used is deterministic, the leakage preserves the per-column counts of matching values between the plaintext inputs $X$ and $Y$.

\begin{proposition}
	\label{prop:mkpsi_inference}
	Let $X$ and $Y$ be sets of records, and let $X_1 \cup X_2$ be a partition of $X$. Then we have
\begin{equation*}
		\colCA(\leakX{}, \leakY)
		= \colCA(\leakX{1}, \leakY) + \colCA(\leakX{2}, \leakY)\footnote{We use standard vector operations; addition and subtraction are applied element-wise.}.
	\end{equation*}
\end{proposition}

Proofs are given in Appendix~\ref{proof:mkpsi_equiv} and~\ref{proof:mkpsi_inference}, respectively.

From Prop.~\ref{prop:mkpsi_inference} we obtain $\colCA(\leakX{2}, \leakY)
  = \colCA(\leakX{}, \leakY) - \colCA(\leakX{1}, \leakY).$
Here, $\leakX{2}$ denotes the (hypothetical) leakage that would result from a protocol run on $X_2$, which is never actually executed. This is acceptable, since we only require $\colCA(\leakX{2}, \leakY)$ for the attack, and this vector can be inferred without knowing $\leakX{2}$ explicitly.

For a leaf node containing a single record, i.e., $X = \{\bx\}$, the vector $\colCA(\leakX{},\leakY)$ is binary: its $i$-th entry is $1$ if and only if the $i$-th value of $\bx$ appears in $Y$, and $0$ otherwise.
More generally, consider any node with record set $X$. Suppose that after querying this node we obtain
\[
    \bc=\colCA(\leakX{}, \leakY) \in \{0, |X|\}^{\ell_{\rec}}.
\]
By Prop.~\ref{prop:mkpsi_equiv}, this equals $\colCA(X,Y)$, so the $i$-th entry counts how many records in $X$ have their $i$-th value in $\Ispace[Y]$. If the $i$-th entry is $|X|$, then \emph{every} record in $X$ has its $i$-th value in $Y$; if it is $0$, then \emph{no} record in $X$ has its $i$-th value in $Y$. Thus, for such a node, each column is either entirely positive (all values occur in $Y$) or entirely negative (no value occurs in $Y$).
Thus for each $i\in[0,\dots,\ell_{\rec}-1]$ if $\bc[i]=|X|$ we add $\{\bx[i]: \bx\in X\}$ to $\posSet$, and otherwise we add it to $\negSet$. Once we have processed all the nodes in this way, $\posSet$ must thus include all values in $\Ispace[T]\cap\Ispace[Y]$.

% For a leaf node storing a single record, i.e., $X = \{\bx\}$, the vector $\colCA(\leakX{},\leakY)$ is binary: its $i$-th entry is $1$ if and only if the $i$-th value of $\bx$ appears in $Y$, and $0$ otherwise. More generally, once a node is queried and the resulting sum entry in the vector is the number of records in that set,

% $\colCA(\leakX{}, \leakY) \in \{0, |X|\}^{\ell_{\rec}}$ for some $X$, Prop.~\ref{prop:mkpsi_equiv} implies that, for each column, either all or none of the values in that column of $X$ occur in $Y$, depending on whether the corresponding entry equals $|X|$ or $0$.


The remaining component of our adapted attack is a heuristic that (i) decides which child to follow during DFS traversal and (ii) provides the priority for enqueuing the other child. For any set $X$, this heuristic must be computable from $X$ and $\colCA(\leakX{}, \leakY)$ alone, since this is all we know about the (hypothetical) leakage for that node. For $\bc = \colCA(\leakX{}, \leakY)$, we define
\begin{equation}
      p_{MK}^+(\bc, X) := \frac{\sum_{x \in \bc} x}{\ell_{\rec} |X|}.
\end{equation}
As in the original PSI-CA attack~\cite{USENIX:GHLWJL22}, our heuristic prioritizes the child node whose subsets contain more matched values, which increases the fraction of the intersection that can be recovered when the adversary is limited to a bounded number of protocol invocations.
We additionally propose two further heuristics in~\ref{ap:IRR:heuristics} and evaluate our three heuristics in Appendix~\ref{ap:evaluation}. 

The pseudocode of \mkpsiattack{} is given in Figure~\ref{fig:MKPSIattack} (Appendix~\ref{ap:VIR}).
%The attack is similar to the original PSI-CA attack, with the difference that we maintain two sets $\posSet$ and $\negSet$ to keep track of the inferred positive and negative membership information.

\begin{theorem}\label{thm:VIR-attack-correctness}
	Let $T$ be a target set of records and $Y$ be the recovery set of records. 
    Then $\mkpsiattack^{\calF_{\LMKPM}(\cdot;Y)}(T)$~(Figure~~\ref{fig:MKPSIattack}) achieves value intersection recovery (Def.~\ref{def:VIR_goal}).
\end{theorem}

The proof can be found in Appendix~\ref{proof:VIR-attack-correctness}.

\heading{Time and query complexity.} 
Let $n = |T|$, $m = |Y|$, and let $\ell_{\rec}$ be the maximum record length in $T$ and $Y$. Assume $n$ is a power of two and that priority-queue operations \push{} and \pop{} take amortized time \bigO{\log n}. Since $n$ nodes are pushed and popped in total, this contributes \bigO{n \log n} time.
For inputs $X$ of size $a$ and $Y$ of size $b$, $\colCA(X,Y)$ can be computed in expected time \bigO{\ell_{\rec}(a+b)}. It is called once at the root and for half the nodes at each depth, yielding an expected total cost of $\bigO{\ell_{\rec} n(\log n + m)}$. The heuristic $p_{MK}$ adds only lower-order terms, so the overall expected runtime is $\bigO{\ell_{\rec} n(\log n + m)}$.

Like the original PSI-CA attack, \mkpsiattack{} requires at most $n$ protocol invocations, though this bound is loose due to early termination of DFS traversals (see Section~\ref{sec:evaluation} for an empirical evaluation).
Even when the number of protocol invocations is restricted, partial intersection recovery remains feasible (see Appendix~\ref{ap:evaluation}).


