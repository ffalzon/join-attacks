\section{Analysis of PSU and PSU-CA}

While PSU and PSU-CA have received increasing attention, the information leaked by their functionalties remains largely unexplored. Frikken~\cite{ACNS:Frikken07} noted that submitting an empty set in PSU fully reveals the peer's input and suggested abort-based mitigations. Jia et al.~\cite{USENIX:JSZG24} further analyzed PSU leakage patterns, showing that Guo et al.'s~\cite{USENIX:GHLWJL22} PSI-CA attack extends to certain PSU variants, even under early-abort conditions. They proposed an ``enhanced'' PSU functionality that delays leakage until protocol termination to strengthen rate-limiting mitigations.


We demonstrate that such countermeasures are insufficient by introducing an intersection-recovery attack against PSU that requires only two protocol executions and which does not rely on the adversarial input set being empty or disjoint from the victim set. We then prove that PSU-CA leaks at least as much information as PSI-CA by constructing a reduction showing that any PSI-CA attack with $q$ queries can be transformed into a PSU-CA attack with $q{+}3$ queries. Finally, we show that our PSU-CA attack extends to Meta's $\PrivateID$ protocol and, under mild assumptions, to the $\MKPM$ functionality.


\subsection{Analysis of PSU}\label{sec:psu-attack}

Recall that the input-malicious party $\calA$ knows its own input set $X$
and can learn $X' \cup Y$ by invoking $\PSU(;Y)$. The adversary's goal is to recover $X \cap Y$.
Our attack is based on the following equality:
\begin{equation}
	\label{eqn:PSU_basis}
	X \cap Y = (X \cup Y) \setminus (Y \setminus X) \setminus (X \setminus Y)
\end{equation} 

Note that both $X \cup Y$ and $Y \setminus X$ can be easily determined. The former is the direct output of evaluating $\PSU{}$, and the latter can be computed as 
$(X \cup Y) \setminus X = (X \setminus X) \cup (Y \setminus X) = Y \setminus X$.
The key challenge, therefore, lies in determining $X \setminus Y$. To address this, we make two key observations.

\begin{prop}\label{prop:PSU_difference_distributes}
For any sets $X, Y$ and any partition $X_1 \cup X_2$ of $X$, it holds that
$X \setminus Y = (X_1 \setminus Y) \cup (X_2 \setminus Y).$
\end{prop}


As mentioned previously, while the PSU and PSU-CA functionalities have received increased attention lately, 
the information they reveal about their inputs has not been studied yet.
However, some special cases have been acknowledged in the literature.
Frikken~\cite{Frikken07} points out that providing the empty set as input for PSU immediately reveals the other party's input
and proposes countermeasures against this, such as aborting the protocol execution if one of the input sets is empty or 
only computing the set union if the intersection is not empty.
More recently, Jia et al.~\cite{Jia24} analyzed the leakage patterns of common PSU protocols and highlight that Guo et al.'s attack on PSI-CA (see \cref{ch:PSICA_attack})
also applies to some of these leakage patterns, even when the protocol executions are aborted early. 
They propose an ``enhanced'' PSU functionality which can only be implemented by protocols that reveal their leakage at the end of the protocol execution
in order to make rate-limiting a more effective countermeasure. 
In this chapter, we show that these precautions are ineffective by presenting an intersection recovery attack against PSU
which requires only two PSU evaluations and does not rely on empty sets or sets that are disjoint with the victim set as inputs.

Furthermore, we show that the PSU-CA functionality reveals at least as much information about its inputs as PSI-CA
by reducing PSI-CA to PSU-CA.
Namely, we show that any intersection recovery attack against PSI-CA that makes $q$ PSI-CA evaluations 
can be used to construct an intersection recovery attack against PSU-CA that makes $q+3$ PSU-CA evaluations.  
We then merge this reduction with Guo et al.'s PSI-CA attack, which allows us to save two of the three additional PSU-CA evaluations.
Moreover, we demonstrate that our PSU-CA attack also applies to the functionality of Meta's PrivateID protocol and 
-- under reasonable assumptions -- to the MKPM functionality we formalized in \cref{sec:prel_leakage}.
% Recent years have seen a spike in interest in the \emph{Private Set Union} (PSU) functionality,
% accompanied by several proposals for MPC and 2PC protocols implementing PSU\smalltodo{Put some examples here.}.
% One central goal of any PSU protocol is to hide the intersection of the inputs, 
% since knowledge of the intersection allows one to break the input privacy of the protocol. 
% In the two-party case, knowing $X$, $X \cap Y$ and $X \cup Y$,
% one can easily compute $Y = (X \cup Y) \setminus (X \setminus (X \cap Y))$.

% Despite increased interest, the privacy implications of the \PSU{} functionality itself 
% have not yet been analyzed. 
% We close this gap in \cref{sec:PSU_attack} for the two-party PSU functionality. 
% In particular, we show that a few basic set-theoretic observations and two \PSU{} evaluations
% lead to an intersection-revealing attack on the two-party PSU functionality,
% assuming an input-malicious party $A$.
% Our attack highlights a considerable risk of deploying PSU under very reasonable assumptions on the inputs
% and suggests that PSU protocols may be of limited use without further mitigations.
% Recalling the overarching threat model of this work, we assume an input-malicious party $A$, 
% which can evaluate the PSU functionality arbitrarily often and is able to choose its input freely.
% We assume the victim set $Y$ to be static. 
% $A$ obtains a target set $X$ and has the goal of recovering $X \cup Y$.


% The attack we present in \cref{sec:PSU_attack} requires the knowledge of the full set union,
% making it inapplicable in these cases.
% Therefore, we also present an intersection-recovery attack against the \emph{Private Set Union Cardinality} (PSU-CA) functionality in \cref{sec:PSUCA_attack}.
% \PSUCA{} is also of independent interest, as it too has received increased attention recently\smalltodo{cite some examples}. 
% As is the case with \PSU{}, \PSUCA{} has received increased attention recently, 
% while its implications on privacy remain unclear.

% As our second contribution in this chapter, 
% we present a search-tree-based intersection-recovery attack against \PSUCA{} in \cref{sec:PSUCA_attack},
% inspired Guo et al.'s attack against \PSICA \cite{Guo22}. 


\section{Et Two, PSU?}\label{sec:PSU_attack}
Recall that we assume an input-malicious party $A$ which knows its own input set $X$
and can learn $X' \cup Y$ for arbitrarily many choices of $X'$ against a fixed set $Y$
by evaluating \PSU{}. The goal of $A$ is to recover $X \cap Y$.
Our attack is based on the following equality:
\begin{equation}
	\label{eqn:PSU_basis}
	X \cap Y = (X \cup Y) \setminus (Y \setminus X) \setminus (X \setminus Y)
\end{equation} 

Note that $(X\cup Y)$ and $Y\setminus X$ can easily be determined.
The former is a direct result of evaluating \PSU{} and one can subsequently compute
$(X \cup Y) \setminus X = (X \setminus X) \cup (Y \setminus X) = Y \setminus X$.
The actual interest therefore lies in determining $X\setminus Y$.
To this end, we make two observations.
Recall that a partition of a set $X$ is a pair of subsets $X_1, X_2 \subseteq X$ such that $X_1 \cap X_2 = \emptyset$ and $X_1 \cup X_2 = X$.

\begin{proposition}\label{prop:PSU_difference_distributes}
	For any two sets $X$ and $Y$ and any partition $X_1, X_2$ of $X$, we have $X \setminus Y = (X_1 \setminus Y) \cup (X_2 \setminus Y)$.
\end{proposition}
\begin{proof}
	Follows directly from the fact that the set difference distributes over the union:
	$X \setminus Y = (X_1 \cup X_2) \setminus Y = (X_1 \setminus Y) \cup (X_2 \setminus Y)$.
\end{proof}

\begin{proposition}\label{prop:PSU_comp_partial_difference}
	Let $X$ and $Y$ be two sets and let $X_1, X_2$ be a partition of $X$.
	Furthermore, let $Z_1 := X_1 \cup Y$ and $Z_2 := X_2 \cup Y$. 
	Then, $X_1 \setminus Y = X_1 \setminus Z_2$ and $X_2 \setminus Y = X_2 \setminus Z_1$.
\end{proposition}
\begin{proof}
	We prove $X_1 \setminus Y = X_1 \setminus Z_2$,
	i.e., for any $x \in X_1$ we have $x \not \in Y \iff x \not \in Z_2$.
	We prove the two directions separately.
	\begin{description}
		\item[$(\Rightarrow)$] Assume $x \in X_1$ and $x \not \in Y$.
		Since $X_1 \cap X_2 = \emptyset$, we have $x \not \in X_2$.
		Since $x \not \in Y$ by assumption, we have $x \not \in (X_2 \cup Y) = Z_2$.
		\item[$(\Leftarrow)$] To arrive at a contradiction, assume $x \in X_1, x \not \in Z_2$ 
		and $x \in Y$.
		$x \not \in Z_2$ implies $x\not\in X_2$ and $x\not\in Y$, 
		the latter of which directly contradicts our assumptions. 
	\end{description}
	The proof for $X_2 \setminus Y = X_2 \setminus Z_1$ follows analogously.
\end{proof}

We could combine Propositions~\ref{prop:PSU_difference_distributes} and \ref{prop:PSU_comp_partial_difference}
with \cref{eqn:PSU_basis} to obtain $X \cap Y$ with three evaluations of \PSU.
However, since $X \cup Y = (X_1 \cup Y) \cup (X_2 \cup Y)$, the adversary can compute the full union from the two partial unions,
thus, saving one evaluation.
The complete attack \PSUattack{} is described in \cref{fig:PSU_attack}.

\begin{theorem}
	For any sets $X$ and $Y$, $\PSUattack^{\PSU(\cdot, Y)}(X)$ outputs $X\cap Y$.
\end{theorem}
\begin{proof}
	Follows directly from \cref{eqn:PSU_basis} and Propositions~\ref{prop:PSU_difference_distributes} and \ref{prop:PSU_comp_partial_difference}.
\end{proof}

This is a very general attack, which only requires that 
\PSU{} can be evaluated twice with the disjoint sets $X_1$ and $X_2$ as the adversary's inputs while the victim set $Y$ remains static.
These assumptions are well within the security model of common PSU deployments.
The attack could even be considered valid assuming a more restricted semi-honest adversary,
as long as the attacker can observe the result of two \PSU{} evaluations involving disjoint adversarial inputs and a static victim set.
% In such scenarios, spending computational resources on privately computing a set union is therefore in vain
% and a non-private approach yields the same result with the same implications on privacy at a smaller cost.

\begin{figure}
	\begin{pchstack}[boxed, center]
		\procedure[linenumbering]{$\PSUattack^{\PSU(\cdot, Y)}(X)$}{
			\text{Partition $X$ into $X_1, X_2$} \\
			Z_1 \gets \PSU(X_1, Y) \\
			Z_2 \gets \PSU(X_2, Y) \\
			Z \gets Z_1 \cup Z_2 \\
			D_Y \gets Z \setminus X \pccomment{$D_Y = Y \setminus X$} \label{lin:PSUDiff_Z-X}\\
			D_{X_1} \gets X_1 \setminus Z_2 \pccomment{\cref{prop:PSU_comp_partial_difference}} \\
			D_{X_2} \gets X_2 \setminus Z_1 \pccomment{\cref{prop:PSU_comp_partial_difference}} \\
			D_X \gets D_{X_1} \cup D_{X_2} \pccomment{\cref{prop:PSU_difference_distributes}} \\
			S \gets Z \setminus D_Y \setminus D_X \pccomment{\cref{eqn:PSU_basis}}\\
			\pcreturn S
		}
	\end{pchstack}
	\caption{Intersection-recovery attack \PSUattack{} with oracle access to $\PSU(\cdot, Y)$ for a fixed $Y$. 
	Note that $Y$ is part of the oracle and unknown to the adversary.}
	\label{fig:PSU_attack}
\end{figure}

\section{PSU-CA Attack}\label{sec:PSUCA_attack}
The \PSUCA{} functionality leaks considerably less information about the victim set than \PSU{},
preventing the direct inference of the intersection presented in the last section.
However, there is a close relationship between the cardinalities of the union and the intersection of two sets.
This raises the question whether existing intersection recovery attacks against PSI-CA can be modified to work against PSU-CA.
We answer this question affirmatively in this section by presenting a generic construction that transforms any intersection recovery attack against PSI-CA
into one against PSU-CA. We then merge this construction with Guo et al.'s attack against PSI-CA, resulting in an intersection recovery attack against PSU-CA
which requires fewer PSU-CA evaluations than the generic construction.

Let $X$ and $Y$ be two sets. As before, $X$ is the attacker's target set and $Y$ the victim set.
The attacker can determine $|X' \cup Y|$ for arbitrarily many choices of $X'$ by evaluating \PSUCA{} and must recover $X \cap Y$.
Our generic construction is based on the following relation between the set union and intersection cardinalities:

\begin{equation}\label{eqn:union_intersect_cardinalities}
	|X \cup Y| = |X| + |Y| - |X \cap Y|
\end{equation}

Reorganizing terms yields $|X \cap Y| = |X| + |Y| - |X \cup Y|$.
In other words, the attacker can compute the cardinality of the intersection if it knows the cardinalities of the victim set and the union of the victim and target sets.
This enables the adversary to translate between the PSU-CA and PSI-CA functionalities, thus, allowing it to leverage any intersection recovery attack for PSI-CA against PSU-CA.

One issue remains: the adversary does not know $|Y|$ in the general case.
While some PSU-CA protocols may leak this information, not all do 
and we do not want to concede this loss of generality.
As an immediate solution, the attacker could choose the empty set as input for \PSUCA{} in order to obtain $|\emptyset \cup Y| = |Y|$.
However, in light of the commonly acknowledged loss of privacy when using an empty set as input for \PSU{} -- which we outlined in the introduction of this chapter -- 
precautions against this may have also been taken in deployments of \PSUCA{} protocols.   
We therefore present a method to determine $|Y|$ with three \PSUCA{} evaluations that avoids evaluating $\PSUCA(\emptyset, Y)$.

\begin{proposition}\label{prop:PSUCA_comp_m}
	Let $X$ and $Y$ be two sets and let $X_1, X_2$ be a partition of $X$.
	Moreover, let $z:= |X \cup Y|$, $z_1 := |X_1 \cup Y|$ and $z_2 := |X_2 \cup Y|$. Then, we have 
	\begin{equation*}
		|Y| = z_2 - (z - z_1)
	\end{equation*}
\end{proposition}
\begin{proof}
	Let $n = |X|, n_1 = |X_1|$ and $n_2 = |X_2|$.
	By definition, $X_1$ contains exactly $n - n_1$ fewer elements than $X$ 
	and $X_1 \cap Y$ exactly $z-z_1 \leq n - n_1$ fewer than $X \cap Y$.
	Exactly $d := (n - n_1) - (z - z_1)$ 
	elements of $X \setminus X_1$ must therefore be contained in $Y$, i.e., $|(X\setminus X_1) \cap Y| = d$.
	Since $X_1$ and $X_2$ form a partition of $X$, we have $X\setminus X_1 = X_2$ and $n-n_1 = n_2$
	and, thus, $|X_2 \cap Y| = d$. Then,
	\begin{equation*}
		\begin{split}
			z_2 & = |X_2 \cup Y| \\
			& = |X_2| + |Y| - |X_2 \cap Y| \\
			& = n_2 + |Y| - ((n-n_1) - (z - z_1)) \\
			& = n_2 + |Y| - (n_2 - (z - z_1)) \\
			& = |Y| + (z - z_1)
		\end{split}
	\end{equation*}
	Reordering terms concludes the proof.
\end{proof}

\begin{figure}
	\centering
	\begin{pchstack}[boxed, center]
		\procedure[linenumbering]{$\bdv_\adv^{\PSUCA(\cdot, Y)}(X)$}{
			\text{Partition $X$ into two disjoint } \pcskipln\\
			\pcparbox{subsets $X_1, X_2$.} \\
			z \gets \PSUCA(X, Y) \label{lin:PSUCA_generic_1}\\
			z_1 \gets \PSUCA(X_1, Y) \\
			z_2 \gets \PSUCA(X_2, Y) \label{lin:PSUCA_generic_3}\\
			m \gets z_2 - (z - z_1) \pccomment{\cref{prop:PSUCA_comp_m}} \\
			Z \gets \adv^{\PSICA\text{-}\textsf{Sim}}(X) \\
			\pcreturn Z
		}
		\pchspace
		\procedure[linenumbering]{$\PSICA\text{-}\textsf{Sim}(X')$}{
			z \gets \PSUCA(X', Y) \\
			k \gets |X'| + m - z \pccomment{\cref{eqn:union_intersect_cardinalities}} \\
			\pcreturn k
		}
	\end{pchstack}
	\caption{Generic construction of an intersection recovery attack \bdv{} against PSU-CA given an intersection recovery attack \adv{} against PSI-CA. 
	Note that $Y$ is part of the oracle and unknown to either attack.}
	\label{fig:PSUCA_generic}
\end{figure}

With three additional PSU-CA evaluations in the beginning of the attack, 
the adversary can therefore simulate the PSI-CA functionality perfectly.
We state our result in the following theorem:

\begin{theorem}
	Let $X$ and $Y$ be two arbitrary sets.
	For every adversary $\adv$ such that $\adv^{\PSICA(\cdot, Y)}(X) = X \cap Y$ which makes $q\in\N$ \PSICA{} queries,
	there is an an adversary $\bdv$ with oracle access to $\PSUCA(\cdot, Y)$ which recovers $X \cap Y$ and makes $q + 3$ \PSUCA{} queries. 
\end{theorem}
\begin{proof}
	We provide a concrete construction of \bdv{} for any \adv{} in \cref{fig:PSUCA_generic}.
	Correctness of \bdv{} follows directly from \cref{eqn:union_intersect_cardinalities} and \cref{prop:PSUCA_comp_m}.
	Clearly, \bdv{} makes three PSU-CA evaluations on lines~\ref{lin:PSUCA_generic_1}~-~\ref{lin:PSUCA_generic_3} and one for every \PSICA{} query made by \adv{}.
	Since determining $m$ and translating union cardinalities to intersection cardinalities only involves simple integer arithmetic, 
	\bdv{} has a similar runtime to \adv{}.
\end{proof}

We now integrate the generic construction from \cref{fig:PSUCA_generic} into the $\mathsf{PSI\text{-}CA\text{-}Search}\allowbreak\mathsf{Tree}$ attack, 
which we introduced in \cref{ch:PSICA_attack}.
Recall that the attack starts by building a binary tree $T$ such that the root $T.\treeRoot$ holds the target set $X$ 
and the sets stored at the two children of any node in the tree form a partition of the set stored at their parent.
In particular, the immediate children of $T.\treeRoot$ store the sets $X_1$ and $X_2$, which form a partition of $X$. 
The attack then evaluates \PSICA{} on $X$ and $X_1$ (the latter happens in the first loop iteration) and computes $|X_2 \cap Y| = |X \cap Y| - |X_1 \cap Y|$.
This inference is not possible if the attacker can only evaluate \PSUCA{}, as it needs to know $m$.
However, using \cref{prop:PSUCA_comp_m} the attacker can determine $m$ by evaluating \PSUCA{} on $X$, $X_1$ and $X_2$ and 
then infer $|X \cap Y| = |X| + m - |X \cup Y|$ and $|X_i \cap Y| = |X_i| + m - |X_i \cup Y|$ for $i\in\{1,2\}$.
This is almost equivalent to how \PSICAattack{} attack processes the tree root and its two child nodes, 
with the difference that we require an additional evaluation of \PSUCA{} to determine $|X_2 \cap Y|$. 
After that, the attacker can carry out the rest of the PSI-CA attack, translating union to intersection cardinalities using \cref{eqn:union_intersect_cardinalities}.
The attack is shown in \cref{fig:PSUCA_attack}.
Note that in contrast to \PSICAattack{}, we maintain two sets $\posSet$ and $\negSet$, 
where $\posSet$ contains all elements of $X$ that belong to the intersection and $\negSet$ all elements that do not occur in $Y$.
This allows us to evaluate the performance of the attack in more detail under limited query budgets, see \cref{ch:experiments}. 
We state the correctness in the following theorem:

\begin{theorem}
	Let $X$ and $Y$ be two arbitrary sets. 
	$\PSUCAattack^{\PSUCA(\cdot, Y)}(X)$ outputs $X \cap Y$.
\end{theorem}
\begin{proof}
	Follows directly from the correctness of \PSICAattack{} and \cref{prop:PSUCA_comp_m} and \cref{eqn:union_intersect_cardinalities}.
\end{proof}

\begin{figure}
	\Wider[8em]{
	\begin{pchstack}[boxed, center]
		\procedure[linenumbering]{$\PSUCAattack^{\PSUCA(\cdot, Y)}(X)$}{
			\text{Initialize empty set $\posSet$, $\negSet$.} \\
			\text{Initialize max-priority queue $Q$.} \\
			T \gets \mathsf{buildTree}(X) \\
			T_L = T.\treeRoot.\treeLeftChild; \; T_R = T.\treeRoot.\treeRightChild \\
			X_L = T_L.\treeSet; \; X_R = T_R.\treeSet \\
			\gamechange{$z \gets \PSUCA(X, Y)$} \label{lin:PSUCA_attack_eval1} \\
			\gamechange{$z_L \gets \PSUCA(X_L, Y)$} \label{lin:PSUCA_attack_eval2} \\
			\gamechange{$z_R \gets \PSUCA(X_R, Y)$} \label{lin:PSUCA_attack_eval3} \\
			\gamechange{$m \gets z_R - (z - z_L)$} \pccomment{\cref{prop:PSUCA_comp_m}} \\
			\gamechange{$k \gets |X| + m - z$} \pccomment{\cref{eqn:union_intersect_cardinalities}}\\
			\gamechange{$k_L \gets |X_L| + m - z_L$} \pccomment{\cref{eqn:union_intersect_cardinalities}}\\
			\gamechange{$k_R \gets |X_R| + m - z_R$} \pccomment{\cref{eqn:union_intersect_cardinalities}}\\
			\gamechange{$Q.\push(p_{\PSICA}(z_L, |X_L|), (T_L, k_L))$} \\
			\gamechange{$Q.\push(p_{\PSICA}(z_R, |X_R|), (T_R, k_R))$} \\
			\pcwhile Q \text{ is not empty} \pcdo \\
			\t	(T_c, k_c) \gets Q.\pop() \pcskipln\\
			\t	X_c \gets T_c.\treeSet \\
			\t 	\pclinecomment{DFS path traversal} \\
			\t	\pcwhile 0 < k_c < |X_c| \pcdo \label{lin:PSUCA_inner_while_condition} \\
			\t	\t	T_L \gets T_c.\treeLeftChild; \; T_R \gets T_c.\treeRightChild \\
			\t	\t	X_L \gets T_L.\treeSet; \; X_R \gets T_R.\treeSet \\
			\t 	\t	\gamechange{$z_L \gets \PSUCA(X_L, Y)$} \\
			\t	\t	\gamechange{$k_L \gets |X_L| + m - z_L$} \pccomment{\cref{eqn:union_intersect_cardinalities}} \\
			\t	\t	k_R \gets k_c - k_L \\
			\t	\t	p_L \gets p_{\PSICA}(k_L, |X_L|) \\
			\t 	\t	p_R \gets p_{\PSICA}(k_R, |X_R|) \\
			\t	\t	\pcif p_L > p_R \pcthen \pcskipln \\
			\t	\t	\t	\pclinecomment{Continue with left child} \\
			\t	\t	\t	T_c \gets T_L; \; k_c \gets k_L \\
			\t	\t	\t	Q.\push(p_R, (T_R, k_R)) \\
			\t	\t	\pcelse \pcskipln\\
			\t	\t	\t	\pclinecomment{Continue with right child} \\
			\t	\t	\t	T_c \gets T_R; \; k_c \gets k_R \\
			\t	\t	\t	Q.\push(p_L, (T_L, k_L)) \\
			\t	\pcif k_c = |X_c| \pcthen \label{lin:PSUCA_add_condition}\\
			\t	\t	\posSet \gets \posSet \cup X_c \\
			\t	\pcelse \\
			\t	\t	\negSet \gets \negSet \cup X_c \\
			\pcreturn \posSet, \negSet
		}
		\pchspace	
		\procedure[linenumbering]{$\mathsf{buildTree}(\setT)$}{
			\text{Initialize a tree $T$ with a single}\pcskipln\\
			%\parbox{4.7cm}{\linespread{1.3}\selectfont node $\treeRoot$, which stores \setT. Build a balanced binary search tree by recursively dividing the set stored at a node into two disjoint subsets of roughly equal size.}\\
			\pcparbox{node $\treeRoot$, which stores \setT. 
			Build a balanced binary search tree by recursively dividing the set stored at a node 
			into two disjoint subsets of roughly equal size.} \\
			% \text{node $\treeRoot$, which stores \setT.} \\
			% \text{Build a balanced binary tree by} \pcskipln \\
			% \text{recursively dividing the set} \pcskipln \\
			% \text{stored at a node into two} \pcskipln \\
			% \text{disjoint non-empty subsets.}\\
			\pcreturn T
		}
	\end{pchstack}}
	\caption{Intersection-recovery attack \PSUCAattack{} with oracle access to $\PSUCA(\cdot, Y)$ for a fixed victim set $Y$.
	Note that $Y$ is part of the oracle and unknown to the adversary.
	Changes to \PSICAattack{} are highlighted in gray.}\label{fig:PSUCA_attack}
\end{figure}

For our experimental evaluation in \cref{ch:experiments}, we additionally propose two further heuristics: 
$p_{\PSICA}^-$, which prioritizes the reconstruction of the set difference $X \setminus Y$ 
over that of the intersection,
and $p_{\PSICA}^*$, whose aim is to maximize the total (positive and negative) membership information we can infer.
In light of these additional definitions, we define the alias $p_{\PSICA}^+ := p_{\PSICA}$ to avoid confusion in the presentation of our experimental results.
$$p_{\PSICA}^-(k, |X|) := \frac{|X| - k}{|X|}$$
$$p_{\PSICA}^*(k, |X|) := \frac{\max(k, |X| - k)}{|X|}$$

\textbf{Time and Query Complexity.} 
We assume $n = |X|$ is a power of two. However, the analysis holds for general $n$; 
see the argument in the analysis of \PSICAattack{} in \cref{ch:PSICA_attack}.
As $n$ is a power of two, there are $\sum_{i=0}^{\log n} 2^i = 2n - 1$ nodes in $T$.
The two loops collectively visit each of these nodes at most once.
The body of the inner loop requires only constant time except for the $\push$ operation,
which requires amortized \bigO{\log n} time. 
This yields an overall time complexity of \bigO{n\log n}.

\PSUCAattack{} evaluates \PSUCA{} three times in lines~\ref{lin:PSUCA_attack_eval1}~-~\ref{lin:PSUCA_attack_eval3}.
Ignoring early terminations, the attack then makes further evaluations for at most half of the nodes in the rest 
of the binary search tree (excluding the root and its two direct children).
As mentioned above, there are $2n - 1$ nodes in $T$.
The attack therefore evaluates \PSUCA{} at most $(2n - 4) / 2 + 3 = n + 1$ times.
Recall from \cref{ch:PSICA_attack} that \PSICAattack{} makes at most $n$ \PSICA{} evaluations.
In the worst case, \PSUCAattack{} therefore requires two protocol invocations less than the generic construction in \cref{fig:PSUCA_generic}.
As is the case with \PSICAattack{}, we can expect this number to be lower due to the early termination of DFS path traversals.
See \cref{ch:experiments} for an empirical evaluation.

% The \PSUCA{} functionality leaks considerably less information about the victim set than \PSU{},
% preventing the direct inference of the intersection presented in the last section.
% We therefore resort to an iterative approach, consisting of traversing a binary search tree.
% This approach was first presented in an attack against the 
% \emph{Private Set Intersection Cardinality} (PSI-CA) functionality (see \cref{fig:PSI-CA})
% by Guo et al. \cite{Guo22}. See \cref{ch:PSICA_attack} for a more detailed overview of the attack\smalltodo{Depending on final layout, move this overview here.}.
% We apply a similar approach to \PSUCA{} to obtain an intersection-revealing attack in this section.
% In fact, \dots\smalltodo{Find the paper, I think it's the same that mentions trivial empty-set attack.} highlight that
% protocols implementing the \PSU{} functionality
% must not leak the size of its intersection's inputs
% to prevent applicability of said \PSICA{} attack.
% This rational clearly translates to protocol implementing \PSUCA{}.
% With our attack, we show that \PSUCA{} is equally vulnerable to that approach.

% Let $X$ be the adversary's target set and $Y$ the victim set.
% There are two special cases regarding the size of the union of the two sets,
% which allow for a direct inference of the intersection.
% First, if $|X \cup Y| = |Y|$, then $X \subseteq Y$ and therefore $X \cap Y = X$.
% And second, if $|X \cup Y| = |X| + |Y|$, then $X \cap Y = \emptyset$.
% Naturally, those two cases are very unlikely for general $X$ and $Y$,
% but note that we can adapt them to subsets of $X$:

% \begin{proposition}\label{prop:PSUCA_termination}
% 	Let $X$ and $Y$ be arbitrary sets and let $X' \subseteq X$. 
% \begin{enumerate}
% 	\item[(1)] If $|X' \cup Y| = |Y|$, then $X' \subseteq Y$ and, thus, $X' \subseteq X \cap Y$
% 	\item[(2)] If $|X' \cup Y| = |X'| + |Y|$, then $X' \cap Y = \emptyset$ and, thus, $X' \not\subseteq X \cap Y$
% \end{enumerate}	
% \end{proposition} 

% Now consider any set $S$ and a partition $S_1, S_2$ of $S$,i.e., $S_1 \cup S_2 = S$ and $S_1 \cap S_2 = \emptyset$.
% Since $|S \cup Y| = |S_1 \cup Y| + |S_2 \cup Y| - |Y|$,
% the adversary can infer $|S_2 \cup Y| = |S \cup Y| - |S_1 \cup Y| + |Y|$
% if it knows $|Y|$, $|S\cup Y|$ and $|S_1 \cup Y|$.
% We can leverage this observation to obtain a subset $X'$ such that one of the two cases of \cref{prop:PSUCA_termination} apply.
% Concretely, we can recursively subdivide the target set $X$, assembling a balanced binary search tree
% where the root node contains $X$ and any two siblings form a partition of their parent.
% The two subsets comprising the partition are randomly chosen and of equal size.

% The attack then starts with initializing two empty sets $\posSet$ and $\negSet$, 
% which are iteratively updated and in the end contain $X \cap Y$ and $X \setminus Y$ respectively.
% We traverse the binary tree in a DFS-style manner, starting at the root. At each node during a DFS path traversal,
% we evaluate \PSUCA{} and infer the size of the union of its sibling and the victim set.
% Once we reach a set $X'$ where one of the two cases from \cref{prop:PSUCA_termination} applies,
% the path traversal can be aborted and the intersection updated.
% In particular, if case (1) applies, all elements of $X'$ must lie in the intersection and can therefore
% be added to $\posSet$. On the other hand, if case (2) applies, no elements of $X'$ lie in the intersection 
% and we can add the elements of $X'$ to $\negSet$.

% All non-traversed subtrees are entered into a priority queue for later processing;
% let $X^*$ denote the root of such a subtree.
% To sort the queue, we need a heuristic, which is correlated with the probability of reaching case 1 from \cref{prop:PSUCA_termination}.
% Concretely, we want the heuristic to favor sets $X^*$ from which only a small fraction of elements needs to be removed such that case (1) applies.
% We therefore propose the following heuristic:
% \begin{equation*}
% 	p_{\PSUCA}(|X^* \cup Y|, |X^*|, |Y|) := 1 - \frac{|X^* \cup Y| - |Y|}{|X^*|} 
% \end{equation*}
% In particular, if $|X^* \cup Y| = |Y|$, we have $p_{\PSUCA}(|X^* \cup Y|, |X^*|, |Y|) = 1$.
% Conversely, if $|X^* \cup Y| = |X^*| + |Y|$, $p_{\PSUCA}(|X^* \cup Y|, |X^*|, |Y|) = 0$\smalltodo{Experiments? May choose different heuristic.}.
% $p_{\PSUCA}$ therefore assigns larger values to subtrees 
% that have a higher probability of reaching case 1 from \cref{prop:PSUCA_termination}.
% This aims at maximizing the fraction of the reconstructed intersection 
% in case the allowed number of \PSUCA{} evaluations is limited.
% We also use the same heuristic to determine, 
% whether to continue with the left or right child during a path traversal.
% Note that we do not claim optimality here. 
% Different heuristics may lead better results and we leave investigating this for future work. 
% The full attack is shown in \cref{fig:PSUCA_attack}.

% One issue remains: the adversary does not know $|Y|$ in the general case.
% While some protocols may leak this information, not all do 
% and we do not want to concede this loss of generality.
% We can, however, determine $|Y|$ at the cost of one additional \PSUCA{} evaluation.
% This is acceptable, since it only needs to be computed once.
% Consider again the target set $X$ and a partition $X_1, X_2$ of $X$.
% \begin{proposition}\label{prop:PSUCA_comp_m}
% 	For $z:= |X \cup Y|$, $z_1 := |X_1 \cup Y|$ and $z_2 := |X_2 \cup Y|$, we have 
% 	\begin{equation*}
% 		%z_2 = |Y| + (|X_2| - ((|X| - |X_1|) - (z - z_1)))
% 		|Y| = z_2 - (z - z_1)
% 	\end{equation*}
% \end{proposition}
% \begin{proof}
% 	Let $n = |X|, n_1 = |X_1|$ and $n_2 = |X_2|$.
% 	By definition, $X_1$ contains exactly $n - n_1$ fewer elements than $X$ 
% 	and $X_1 \cap Y$ exactly $z-z_1 \leq n - n_1$ fewer than $X \cap Y$.
% 	Exactly $d := (n - n_1) - (z - z_1)$ 
% 	elements of $X \setminus X_1$ must therefore be contained in $Y$, i.e., $|(X\setminus X_1) \cap Y| = d$.
% 	Since $X_1$ and $X_2$ form a partition of $X$, we have $X\setminus X_1 = X_2$ and $n-n_1 = n_2$
% 	and, thus, $|X_2 \cap Y| = d$. Then,
% 	\begin{equation*}
% 		\begin{split}
% 			z_2 & = |X_2 \cup Y| \\
% 			& = |X_2| + |Y| - |X_2 \cap Y| \\
% 			& = n_2 + |Y| - ((n-n_1) - (z - z_1)) \\
% 			& = n_2 + |Y| - (n_2 - (z - z_1)) \\
% 			& = |Y| + (z - z_1)
% 		\end{split}
% 	\end{equation*}
% 	Reordering terms concludes the proof.
% \end{proof}

% \begin{lemma}
% 	For any sets $X$ and $Y$, let $(\posSet, \negSet) \sample \PSUCAattack^{\PSUCA(\cdot, Y)}(X)$.
% 	Then, $\posSet = X \cap Y$ and $\negSet = X \setminus Y$.
% \end{lemma}
% \begin{proof}
% 	\Todo{This is practically identical to the correctness proof of \mkpsiattack. Will do later.}
% \end{proof}

% \textbf{Time and Query Complexity.} 
% We assume $n = |X|$ is a power of two. However, the analysis holds for general $n$; 
% see the argument in the analysis of Guo et al.'s attack on PSI-CA in \cref{ch:PSICA_attack}.
% As $n$ is a power of two, there are $\sum_{i=0}^{\log n} 2^i = 2n - 1$ nodes in $T$.
% The two loops collectively visit each of these nodes at most once.
% The body of the inner loop is requires only constant time except for the $\push$ operation,
% which requires amortized \bigO{\log n} time. 
% This yields an overall time complexity of \bigO{n\log n}.

% \PSUCAattack{} evaluates \PSUCA{} three times in lines~\ref{lin:PSUCA_attack_eval1}~-~\ref{lin:PSUCA_attack_eval3}.
% Ignoring early terminations, the attack then makes further evaluations for at most half of the nodes in the rest 
% of the binary search tree (excluding the root and its two direct children).
% As mentioned above, there are $2n - 1$ nodes in $T$.
% The attack therefore evaluates \PSUCA{} at most $(2n - 4) / 2 + 3 = n + 1$ times.
% Due to the aforementioned early termination of path traversals, we can expect this number to be lower.
% See \cref{ch:experiments} for an empirical evaluations.

\section{Applications to Private Record Matching}\label{sec:PSUCA_to_matching}
To highlight that our attacks extend beyond specific PSU or PSU-CA protocols, we
show in this section that the \PSUCAattack{} attack can be applied to the functionality of Meta's PrivateID protocol and 
-- with some additional assumptions -- also to the MKPM functionality we formalized in \cref{sec:prel_leakage}.

\subsection{PrivateID}\begin{figure}
	\Wider[3em]{
	\begin{tcolorbox}[colback=white,arc=0mm]
	\begin{description}
		\item[\textbf{Parameters:}] Two parties, $C$ and $P$.
		\item[\textbf{Functionality} $\mathsf{SKPM}(X, Y)$:] \hfill \begin{enumerate}
			\item Receive input sets $X$ from party $C$ and $Y$ from party $P$.
			\item Compute $Z := X \cup Y$.
			\item Sample an injective random function $f \sample \InjFuncs[\Ispace, \G]$.
			\item Compute dictionaries $\MC : \G \to X \cup \{\bot\}$ and $\MP : \G \to Y \cup \{\bot\}$ such that for all $z \in Z$
			\begin{equation*}
				\MC[f(z)] = \begin{cases*}
					z & if $z \in X$ \\
					\bot & otw.
				\end{cases*} \quad\text{and}\quad
				\MP[f(z)] = \begin{cases*}
					z & if  $z \in Y$ \\
					\bot & otw.
				\end{cases*}
			\end{equation*}
		\item Compute $\UID := \{f(z) \setdsc z \in Z\}$.
		\item Send $(\UID, \MC)$ to $C$ and $(\UID, \MP)$ to $P$.
		\end{enumerate}  
	\end{description}
	\end{tcolorbox}}
	\caption{Single-Key Private Matching functionality, implemented by Meta's PrivateID protocol \cite{PMC}.}\label{fig:SKPM_definition}
\end{figure}

Meta's PrivateID protocol~\cite{PMC} implements the Single-Key Private Matching (SKPM) functionality, 
which is the single-key counterpart to the MKPM functionality we formalized in \cref{sec:prel_leakage}.
In this section, we give a brief overview of the SKPM functionality and then show that minimal modifications to \PSUCAattack{}
suffice to learn the intersection of its inputs.

SKPM involves two parties $C$ and $P$ 
with input sets $X \subseteq \Ispace{}$ and $Y \subseteq \Ispace{}$.
The functionality computes $Z := X \cup Y$ and renames the elements of $Z$ by evaluating them under an injective random function,
yielding the set \UID{}.
It then computes two maps $\MC: \UID \to X \cup \{\bot\}$ and $M_P: \UID \to Y \cup \{\bot\}$,
which map elements in $\UID$ to the original elements in $X$ and $Y$ or $\bot$ if the element only occurs in the other party's set. 
In the end, party $C$ receives $\UID$ and $\MC$ and party $P$ $\UID$ and $\MP$ correspondingly.
See \cref{fig:SKPM_definition} for the formal definition.

Clearly, we have $|\UID| = |X \cup Y|$ for any two sets $X$ and $Y$.
We can therefore apply \PSUCAattack{} directly to SKPM 
to recover $X \cap Y$ in at most $|X| + 1$ SKPM evaluations.
Guo et al.~\cite{Guo22} have already examined PrivateID in the context of their intersection recovery attack on \PSICA{},
where they recover $X \cap Y$ in at most $|X|$ protocol invocations.
However, they rely on the fact that PrivateID leaks $|X \cap Y|$ during the protocol execution, 
while our attack relies on the functionality output alone.

\subsection{MK-PrivateID}
Meta's MK-PrivateID protocol~\cite{MPMC} implements the Multi-Key Private Matching (MKPM) functionality we defined in \cref{sec:prel_leakage}.
We show in this section that \PSUCAattack{} can be applied to MKPM to 
learn which records in the target set contain an identifier that also occurs in the victim set.
This corresponds the \emph{Matchable Record Recovery} goal we formalized in \cref{sec:MRR_goal}.
Recall that the attacker is given a set of records \setT{}, the target set, and can evaluate $\MKPM(\setT', \setV)$
for arbitrarily many inputs $\setT'$, while the victim set \setV{} remains static.
The adversary's goal is to determine the set $\setT \sqcap \setV = \{t \in \setT \setdsc \exists v \in \setV\; \exists j, \ell \in \N : t[j] = v[\ell]\}$.

Similar to its single-key counterpart SKPM, 
MKPM outputs a set $\UID$. However, instead of assigning a common uid to two identical records it matches records
using a matching logic (see \cref{fig:match_logic}) and assigns a common uid to pairs of matching records,
as well as a separate uid to every unmatched record in \setT{} and \setV{}.
Thus, taking $|\UID|$ as the the union cardinality to carry out \PSUCAattack{} seems to be a natural approach 
to identify matching records in \setT{}.
 
Recall that the \PSUCAattack{} attack relies on the observation that $|X \cap Y| = |X_1 \cap Y| + |X_2 \cap Y|$,
where $X$ and $Y$ are arbitrary sets and $X_1, X_2$ form a partition of $X$.
Applying \cref{eqn:union_intersect_cardinalities}, this is equivalent to $|X \cup Y| = |X_1 \cup Y| + |X_2 \cup Y| - |Y|$.
Translating this to the multi-key setting, let $\setX \subseteq \setT$ and let $\setX_1, \setX_2$ be a partition of \setX{}.
Moreover, let \UID{}, $\UID_1$, and $\UID_2$ result from evaluating $\MKPM(\setX, \setV)$ and $\MKPM(\setX_i, \setV)$ for $i \in \{1,2\}$ respectively.
Then, the following relation needs to hold:
\begin{equation}
	\label{eqn:MKPM_PSUCA_condition}
	|\UID| = |\UID_1| + |\UID_2| - |\setV|
\end{equation}

Unfortunately, this does not hold for general inputs for two reasons.
First, as we elaborated in \cref{sec:MRR_goal}, the MKPM functionality shuffles the inputs before 
evaluating the matching logic on them. 
As a result, the record matching logic does not consistently match the same number of records in different protocol runs for some fixed inputs,
i.e., different evaluations of \MKPM{} with the same inputs result in \UID{} sets with different cardinalities.
And second, the matching logic violates \cref{eqn:MKPM_PSUCA_condition} even in cases where shuffling the inputs has no effect on the former.

Consider the situation depicted in \cref{fig:MPMK_PSUCA_counterexample}.
On the left, we show an example of a target set \setT{} and victim set \setV{}, 
where two records in the target set share an identifier with the same record in the victim set.
We call this a \emph{many-to-one relation}.
Recall that the matching logic uses the order of identifiers in \setT{} as priorities to resolve such many-to-one relations.
That is, it matches the second target record with the victim record, since it shares its first identifier $\id_3$ with the victim record,
as opposed to the first target record, which shares its second identifier with the victim record. The latter remains unmatched.
The resulting set \UID{} therefore contains two elements: 
one uid for the two matched records and one for the unmatched first target record.
On the right, we show a partition of \setT{}, matched against the same victim set \setV{} (in two separate protocol invocations).
Now isolated and lacking competition from the other record, both target records are matched.
The resulting sets $\UID_1$ and $\UID_2$ therefore both contain one uid.
That is, we have $|\UID| = |\UID_1| + |\UID_2| \neq |\UID_1| + |\UID_2| - |\setV|$, which violates the requirement mentioned above.

\begin{figure}
	\centering
	{\def\linecorr{-.4pt}
	\def\rowspace{\linecorr}
	\def\colspace{1.2cm}
	\def\setspace{5cm}
	\def\setvertspace{.5cm}
	\def\minwidthid{.6cm}
	\def\blockminheight{1.3em}
	\begin{tikzpicture}
		[block/.style={draw,minimum width=#1, minimum height=\blockminheight,font={\tiny}},
		%block/.default=10em,high/.style={minimum height=3em},auto,
		block/.default=10em,high/.style={},auto,
		node distance=0, % initially 1cm
		>=Stealth]
		%node distance=5em,auto]
		% Nodes
		\node[block=\minwidthid,fill=trow-dark] (alice1) {$\id_1$};
		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of alice1] (alice2) {$\id_2$};

		\node[block=\minwidthid,fill=trow-light, below=\rowspace of alice1] (bob1) {$\id_3$};
		\node[block=\minwidthid,fill=trow-light, right=\linecorr of bob1] (bob2) {$\id_4$};

		\coordinate (mid) at ($(alice2)!0.5!(bob2)$);

		\node[block=\minwidthid,fill=trow-dark, right=\colspace of mid] (vic1) {$\id_3$};
		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vic1] (vic2) {$\id_2$};

		\coordinate (right-center) at ([xshift=(\setspace)]mid);


		\node[block=\minwidthid,fill=trow-dark, above=\setvertspace of right-center] (alicesub1) {$\id_1$};
		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of alicesub1] (alicesub2) {$\id_2$};
		\node[block=\minwidthid,fill=trow-dark, right=\colspace of alicesub2] (vicsub1) {$\id_3$};
		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vicsub1] (vicsub2) {$\id_2$};

		\node[block=\minwidthid,fill=trow-dark, below=\setvertspace of right-center] (bobsub1) {$\id_3$};
		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of bobsub1] (bobsub2) {$\id_4$};
		\node[block=\minwidthid,fill=trow-dark, right=\colspace of bobsub2] (vicsub3) {$\id_3$};
		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vicsub3] (vicsub4) {$\id_2$};

		% Connections
		\draw[dashed] (alice2) to (vic1);
		\draw (bob2) to (vic1);

		\draw (alicesub2) to (vicsub1);
		\draw (bobsub2) to (vicsub3);

		% \labels and descriptions
		\coordinate (center1) at ($(alice2.south east)!0.5!(vic1.west)$);
		\coordinate (center2) at ($(alicesub2.east)!0.5!(vicsub1.west)$);
		\coordinate (center3) at ($(bobsub2.east)!0.5!(vicsub3.west)$);

		\node[above=.3cm of alice1.east] (Tlabel) {\tiny$\setT$};
		\node[above=.3cm of vic1.east] (Vlabel1) {\tiny$\setV$};
		\node[below=.6cm of center1] (UIDlabel) {\tiny$|\UID| = 2$};
		
		\node[above=.3cm of alicesub1.east] (Tlabel2) {\tiny$\setT_1$};
		\node[above=.3cm of vicsub1.east] (Vlabel2) {\tiny$\setV$};
		\node[below=.3cm of center2] (UIDlabel1) {\tiny$|\UID_1| = 1$};
		
		\node[above=.3cm of bobsub1.east] (Tlabel3) {\tiny$\setT_2$};
		\node[above=.3cm of vicsub3.east] (Vlabel3) {\tiny$\setV$};
		\node[below=.3cm of center3] (UIDlabel2) {\tiny$|\UID_2| = 1$};
	\end{tikzpicture}}
	\caption{Example of a target set \setT{} and victim set \setV, where \PSUCAattack{} cannot be applied.
	Lines between records indicate potential matches based on matching identifiers. 
	Solid lines denote the matched records chosen by the matching logic.
	Clearly, $|\UID| \neq |\UID_1| + |\UID_2| - |\setV|$.}
	\label{fig:MPMK_PSUCA_counterexample}
\end{figure}
To avoid such cases, we formalize a restriction on the input sets that 
-- if satisfied -- allows us to carry out the attack.
Conveniently, the opposite case, where one record in the target set shares identifiers with multiple records in the victim set,
does not lead to such problems.
It therefore suffices to exclude many-to-one relations.

\begin{definition}[Isolated Set]\label{def:isolated_set}
	Let \setX{} and \setY{} be two sets of records $\setX, \setY \subseteq \Ispace{}^{\leq \lambda}$ for some $\lambda\in\N$.
	We say \setX{} is \emph{$\setY$-isolated}, 
	if for all $v\in \setY$ we have $|\{t \in \setX \setdsc \exists i, j. \; t[i] = v[j]\}| \leq 1$.
\end{definition}

This additional constraint on the protocol inputs excludes some realistic scenarios.
For instance, if the sets contain IP addresses
-- IPv4 addresses behind a Network Address Translation (NAT) device in particular --
such many-to-one relations are likely to occur, as users in the same local network share an address.
However, this does not exclude the scenarios outlined in \cref{sec:threat_model},
where the adversary chooses a specific range of identifiers as its target set, 
such as all phone numbers of a certain area code or all email addresses belonging to some domain.
Furthermore, scenarios where users possess multiple identifiers of some type,
e.g., a private and a work email address, 
but do not share them with other people, are still admitted as well, 
provided that each user's identifiers only occur in at most one record in the target set.
\cref{def:isolated_set} conveniently resolves both issues outlined above,
which we prove in the following two lemmas.

\begin{lemma}
	\label{lem:set_isolation_determinism}
	Let $\setX, \setY \subseteq \Ispace{}^{\leq \lambda}$ be two sets of records. 
	If \setX{} is \setY-isolated, 
	the cardinality of $\UID$ output by $\MKPM(\setX, \setY)$ (\cref{fig:MKPM}) is consistent across multiple evaluations.
\end{lemma}
\begin{proof}
	For any $x \in \setX$, let $\setY_x$ denote the records of \setY{} that share at least one identifier with $x$,
	i.e., $\setY_x := \{y \in \setY \setdsc \exists i, j \in \N : x[i] = y[j]\}$.
	If \setX{} is $\setY$-isolated, we have that $\setY_x \cap \setY_{x'} = \emptyset$ for all $x, x' \in \setX$ with $x \neq x'$. 
	Therefore, there exist no two records in \setX{} that could be matched with the same record in \setY{}.
	
	We first consider sets $\setY_x$ that are not empty.
	Since $x$ can only be matched with some $y \in \setY_x$ and all $y \in \setY_x$ can only be matched with $x$,
	\match{} (\cref{fig:match_logic}) will match $x$ with exactly one $y_x \in \setY_x$,
	which are assigned the same uid (line~\ref{lin:match_common_uid}).
	All other $y \in \setY_x$, i.e., $y \neq y_x$, will remain unmatched and are assigned their own uid (line~\ref{lin:match_unmatched_P_uid}).
	Furthermore, all $y \in \setY$ which do not belong to any $\setY_{x'}$ for any $x' \in \setX$ will also remain unmatched and are assigned their own uid (also line~\ref{lin:match_unmatched_P_uid}).
	Lastly, all $x\in\setX$ for which $\setY_x = \emptyset$ will remain unmatched and receive their own uid (line~\ref{lin:match_unmatched_C_uid}). 
	
	Thus, \UID{} contains one uid for each $y\in \setY$ and one uid for each unmatched $x\in \setX$, i.e.,
	$|\UID| = |\setY| + |\{x \in \setX \setdsc \setY_x = \emptyset\}|$.
	This is independent of the order of the records in \setX{} and \setY{} and
	thus also independent of the shuffling done before the matching step in \MKPM{}.
	Since \MKPM{} only uses randomness to shuffle the inputs, we have proven the lemma.
\end{proof}

\begin{lemma}
	\label{lem:set_isolation_inference}
	Let \setX{} and $\setY \subseteq \Ispace{}^{\leq \lambda}$ be two sets of records and let $\setX_1$ and $\setX_2$
	be a partition of $\setX$. 
	Moreover, let $(\UID, \MC) \sample \MKPM(\setX, \setV)$ and $(\UID_i, M_{C,i}) \sample \MKPM(\setX_i, \setV)$ for $i \in \{1,2\}$.
	If $\setX$ is \setY-isolated, we have $|\UID| = |\UID_1| + |\UID_2| - |\setY|$.
\end{lemma}
\begin{proof}
	We show this by induction on $|\setX_1|$.
	If $|\setX_1| = 0$ all records of $\setY$ are unmatched and, thus, $|\UID_1| = |Y|$.
	Note that $\setX_2 = \setX$ and thus we have $|\UID| = |\UID_2| = |\UID_2| + |\UID_1| - |Y|$.
	In the first equality, we use \cref{lem:set_isolation_determinism}. 
	%that for a fixed input $\idealF$ produces $\UID$ sets of a constant size over multiple evaluations, which we proved in \REF{}.

	Assume $|\setX_1| = n_1$ for some $n_1 > 0$ and $|\UID| = |\UID_1| + |\UID_2| - |\setY|$.
	Since $\setX_1$ and $\setX_2$ form a partition of $\setX$, we must move a record from $\setX_2$ to $\setX_1$
	to achieve $|\setX_1| = n_1+1$. Note that $|\UID|$ remains unchanged due to \cref{lem:set_isolation_determinism}.
	Let $x \in \setX_2$ and let $\setX'_1 := \setX_1 \cup \{x\}$ and $\setX'_2 := \setX_2 \setminus \{x\}$.
	Moreover, let $\UID'_1$ and $\UID'_2$ be the sets of UIDs resulting from evaluating $\MKPM(\setX'_1, \setY)$ and $\MKPM(\setX'_2, \setY)$. 
	We distinguish two cases.
	If no identifier of $x$ occurs in $\setY$, $x$ was assigned its own UID.
	Therefore, $|\UID'_1| = |\UID_1| + 1$ and $|\UID'_2| = |\UID_2| - 1$, which implies the claim.
	
	For the second case, assume $x$ shares some identifiers with $n^*$ records of $\setY$.
	Call this set $\setY_x$.
	Since \setX{} is \setY-isolated, all records $y \in \setY_x$ only share identifiers with $x$,
	but no other $x'\in \setX_2$.
	Thus, $x$ is matched with some $y^* \in \setY_x$,
	i.e., $x$ and $y^*$ are assigned the same $\uid \in \UID_2$.
	After removing $x$ from $\setX_2$, $y^*$ will still be assigned some $\uid' \in \UID'_2$, 
	which it does not share with any $x' \in \setX'_2$, again since $\setX$ is \setY-isolated. 
	Therefore, $|\UID_2| = |\UID'_2|$. 
	Similarly, since $x\not\in \setX_1$, no $y\in \setY_x$ and $x' \in \setX_1$ are assigned the same $\uid \in \UID_1$.
	By the definition of $\setY_x$ and since \setX{} is \setY-isolated, $x$ will be assigned the same $\uid\in \UID'_1$
	as some $y\in\setY_x$ after being added to $\setX_1$, implying $|\UID_1| = |\UID'_1|$.
	The claim then follows trivially.
\end{proof}

With the necessary properties of isolated input sets established, we can assert the correctness of our adaptation:

\begin{theorem}
	Let \setT{} and \setV{} be two sets of records.
	If \setT{} is \setV{}-isolated, then \\
	$\PSUCAattack^{\MKPM(\cdot, \setV)}(\setT)$ recovers $\setT \sqcap \setV$.
\end{theorem}
\begin{proof}
	Let \posSet{} and \negSet{} be the two sets output by $\PSUCAattack^{\MKPM(\cdot, \setV)}(\setT)$.
	Note all records of \setT{} are contained in some subset $\setT_c\subseteq \setT$ that will eventually reach line~\ref{lin:PSUCA_add_condition},
	since the attack only terminates once the priority queue is empty. 
	Therefore, every record of \setT{} is added to either \posSet{} or \negSet{}.
	For any $\setT_c$ reaching line~\ref{lin:PSUCA_add_condition} 
	we have that either (1) $k_c = |\setT_c|$ or (2) $k_c  = 0$ by the loop condition on line~\ref{lin:PSUCA_inner_while_condition}.
	Let $\UID_c$ result from evaluating $\MKPM(\setT_c, \setV)$.
	By \cref{eqn:union_intersect_cardinalities} and \cref{lem:set_isolation_inference}, we have $k_c = |\setT_c| + |\setV| - |\UID_c|$.
	\begin{description}
		\item[Case (1)] If $k_c = |\setT_c|$, then we have $|\UID_c| = |\setV|$, i.e., all records of $\setT_c$ are matched. 
		Since records are only added to \posSet{} if this case applies, we have $\posSet \subseteq \setT \sqcap \setV$.
		\item[Case (2)] If $k_c = 0$, then $|\UID_c| = |\setT_c| + |\setV|$, i.e., no records of $\setT_c$ 
		were matched. Therefore, no record in $\setT_c$ shares any identifiers with any record in $\setV{}$.
		Since records are only added to \negSet{} if this case applies, we have $\negSet \subseteq \setT \setminus (\setT \sqcap \setV)$. 
	\end{description}
	We have therefore shown that \posSet{} only contains matchable records, \negSet{} only contains non-matchable records 
	and that every record in \setT{} is contained in either \posSet{} or \negSet{}.
	This proves the theorem.
\end{proof}

% Moreover, the two termination criteria outlined in \cref{sec:PSUCA_attack} carry over naturally.
% Concretely, if $|\UID| = |\setV|$, then all records of \setX{} are matched, 
% as there would be an additional element in \UID{} for every unmatched record in \setT{} otherwise.
% On the other hand, if no record of \setT{} is matched, every record in \setT{} and \setV{} 
% is associated with a separate, unique $\uid$ and, thus, $|\UID| = |\setT| + |\setV|$.
% Our attack on \PSUCA{} is therefore applicable to MKPM under the condition that \setT{} is \setV-restricted.
% Note that while we assumed an input-malicious party $C$ for our presentation of the attack, 
% the adversary only needs to know $|\UID|$, which is learned by both parties.
% Therefore, the same attack can also be carried out by an input-malicious party $P$ with target set $\setY$ against party $C$ with victim set $\setX$
% when provided with oracle access to $\leak(\setX, \cdot)$.

\textbf{Time and Query Complexity.}
The adaptations described above merely consist of translating the notion of a set union cardinality to the multi-key scenario.
In particular, the elements of $X$ that lie in the intersection $X\cap Y$ are analogous
to the matchable records in \setT{} and \PSUCAattack{} behaves identically in the two settings.
It therefore also has the same worst-case time complexity and maximum number of MKPM evaluations.
Due to said correspondence between $X \cap Y$ and the matched records of \setT{}, 
we can expect the actual number of functionality evaluations for any given intersection size 
(or number of matchable records) to be similar.