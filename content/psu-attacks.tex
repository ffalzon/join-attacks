\section{Analysis of PSU and PSU-CA}

While PSU and PSU-CA have received increasing attention, the information leaked by their functionalties remains largely unexplored. Frikken~\cite{ACNS:Frikken07} noted that submitting an empty set in PSU fully reveals the peer's input and suggested abort-based mitigations. Jia et al.~\cite{USENIX:JSZG24} further analyzed PSU leakage patterns, showing that Guo et al.'s~\cite{USENIX:GHLWJL22} PSI-CA attack extends to certain PSU variants, even under early-abort conditions. They proposed an ``enhanced'' PSU functionality that delays leakage until protocol termination to strengthen rate-limiting mitigations.


We demonstrate that such countermeasures are insufficient by introducing an intersection-recovery attack against PSU that requires only two protocol executions and which does not rely on the adversarial input set being empty or disjoint from the victim set. We then prove that PSU-CA leaks at least as much information as PSI-CA by constructing a reduction showing that any PSI-CA attack with $q$ queries can be transformed into a PSU-CA attack with $q{+}3$ queries. Finally, we show that our PSU-CA attack extends to Meta's $\PrivateID$ protocol and, under mild assumptions, to the $\MKPM$ functionality.


\subsection{Analysis of PSU}\label{sec:psu-attack}

Recall that the input-malicious party $\calA$ knows its own input set $X$
and can learn $X' \cup Y$ by invoking $\PSU(;Y)$. The adversary's goal is to recover $X \cap Y$.
Our attack is based on the following equality:
\begin{equation}
	\label{eqn:PSU_basis}
	X \cap Y = (X \cup Y) \setminus (Y \setminus X) \setminus (X \setminus Y)
\end{equation} 

Note that both $X \cup Y$ and $Y \setminus X$ can be easily determined. The former is the direct output of evaluating $\PSU{}$, and the latter can be computed as 
$(X \cup Y) \setminus X = (X \setminus X) \cup (Y \setminus X) = Y \setminus X$.
The key challenge, therefore, lies in determining $X \setminus Y$. To address this, we make two key observations.

\begin{prop}\label{prop:PSU_difference_distributes}
For any sets $X, Y$ and any partition $X_1 \cup X_2$ of $X$, it holds that
$X \setminus Y = (X_1 \setminus Y) \cup (X_2 \setminus Y).$
\end{prop}

% This follows directly from the distributivity of set difference over union.

% \begin{prop}\label{prop:PSU_comp_partial_difference}
% Let $X$ and $Y$ be two sets, and let $X_1 \cup X_2$ be a partition of $X$.
% Further let $Z_1 := X_1 \cup Y$ and $Z_2 := X_2 \cup Y$.
% Then, $X_1 \setminus Y = X_1 \setminus Z_2 \quad \text{and} \quad X_2 \setminus Y = X_2 \setminus Z_1.$
% \end{prop}
% \begin{proof}
% We show $X_1 \setminus Y = X_1 \setminus Z_2$ i.e.,
% for any $x \in X_1$, we have that $x \notin Y$ if and only if $x \notin Z_2$. 

% ($\Rightarrow$)  
% If $x \in X_1$ and $x \notin Y$, then $x \notin X_2$ since $X_1 \cap X_2 = \emptyset$.  
% Hence $x \notin X_2 \cup Y = Z_2$.

% ($\Leftarrow$)  
% For a contradiction, suppose that $x \in X_1$, $x \notin Z_2$, and $x \in Y$. Then $x \notin Z_2$ implies $x \notin Y$, a contradiction.  
% Thus $x \notin Y$.

% The second equation follows analogously.
% \end{proof}


% % By combining Propositions~\ref{prop:PSU_difference_distributes} and \ref{prop:PSU_comp_partial_difference} with \cref{eqn:PSU_basis} one can recover $X\cap Y$ using three $\PSU$ evaluations.
% % However, since $X \cup Y = (X_1 \cup Y) \cup (X_2 \cup Y)$, the full union can be obtained from the two partial unions. Thus, the adversary can learn the intersection in just two $\PSU$ invocations. 

% % The complete attack \PSUattack{} is described in \ref{fig:PSU_attack}. Correctness of the attack follows directly from \ref{eqn:PSU_basis} and Propositions~\ref{prop:PSU_difference_distributes} and \ref{prop:PSU_comp_partial_difference}.


% Note that the attack is very general---it only requires that 
% $\PSU{}$ be invoked on two disjoint input sets while the victim’s set remains static. These assumptions lie well within the security model of common PSU deployments.


% \subsection{Analysis of PSU-CA}\label{sec:psu-ca-attack}


% The $\PSUCA{}$ functionality leaks considerably less information about the victim set than $\PSU{}$. However, because the cardinalities of set union and intersection are closely related,
% it is natural to ask whether intersection-recovery attacks on PSI-CA (e.g.,~\cite{USENIX:GHLWJL22,NDSS:JiaDuYan24,USENIX:FalTan25}) can be adapted to work against PSU-CA.

% As before, let $X$ be the adversary's target set and $Y$ the victim set; the goal of the adversary is to recover $X \cap Y$ by evaluating $\PSUCA(;Y)$.
% We present a generic construction that transforms any intersection recovery attack against PSI-CA into one against PSU-CA. We then combine this reduction with Guo et al.’s PSI-CA attack to produce a tailored attack on $\PSUCA$  that requires fewer $\PSUCA$ queries than the generic construction.

% Our generic construction is based on the following relation between the set union and intersection cardinalities:
% \begin{equation}
% 	\label{eqn:union_intersect_cardinalities}
% 	|X \cup Y| = |X| + |Y| - |X \cap Y|.
% \end{equation}

% Rearranging gives $|X\cap Y|=|X|+|Y|-|X\cup Y|$; thus, knowing $|Y|$ and $|X\cup Y|$ lets an adversary recover $|X\cap Y|$ and enables any PSI-CA intersection-recovery attack to also work against PSU-CA. One issue that remains is that the adversary does not know $|Y|$. While some $\PSUCA$ protocols reveal this value, others do not, and we wish to maintain generality. We therefore present a method that recovers $|Y|$ using three PSU-CA evaluations, without resorting to the trivial $\PSUCA(\varnothing;Y)$ query.

% \begin{prop}\label{prop:PSUCA_comp_m}
% Let $X$ and $Y$ be two sets, and let $X_1, X_2$ form a partition of $X$. Define $z = |X \cup Y|$, $z_1 = |X_1 \cup Y|$, and $z_2 = |X_2 \cup Y|$. Then, \(|Y| = z_2 - (z - z_1) .\)
% \end{prop}

% The proof can be found in Appendix~\ref{ap:PSUCA_comp_m}.


% % \begin{figure*}
% % 	\centering
% % 	\begin{pchstack}[boxed, center]
% % 		\procedure[linenumbering]{$\bdv_\adv^{\PSUCA(\cdot, Y)}(X)$}{
% % 			\text{Partition $X$ into two disjoint subsets $X_1, X_2$.} \\
% % 			z \gets \PSUCA(X, Y) \label[]{lin:PSUCA_generic_1}\\
% % 			z_1 \gets \PSUCA(X_1, Y) \\
% % 			z_2 \gets \PSUCA(X_2, Y) \label[]{lin:PSUCA_generic_3}\\
% % 			m \gets z_2 - (z - z_1) \pccomment{\Cref{prop:PSUCA_comp_m}} \\
% % 			Z \gets \adv^{\PSICA\text{-}\textsf{Sim}}(X) \\
% % 			\pcreturn Z
% % 		}
% % 		\pchspace
% % 		\procedure[linenumbering]{$\PSICA\text{-}\textsf{Sim}(X')$}{
% % 			z \gets \PSUCA(X', Y) \\
% % 			k \gets |X'| + m - z \pccomment{\Cref{eqn:union_intersect_cardinalities}} \\
% % 			\pcreturn k
% % 		}
% % 	\end{pchstack}
% % 	\caption{Generic construction of an intersection recovery attack \bdv{} against PSU-CA given an intersection recovery attack \adv{} against PSI-CA. 
% % 	Note that $Y$ is part of the oracle and unknown to either attack.}
% % 	\label{fig:PSUCA_generic}
% % \end{figure*}

% With three additional $\PSUCA$ evaluations at the start, the adversary can thus simulate $\PSICA$. In particular, once $|Y|$ is known, it can perform any PSI-CA attack by querying $\PSUCA$ on the same set $X'$ that the original attack would have used, to obtain $|X'\cup Y|$, and then applying \Cref{eqn:union_intersect_cardinalities} with its knowledge of $|Y|$ and $|X'|$ to compute $|X'\cap Y|$. The pseudocode for our generic attack can be found in~\Cref{fig:PSUCA_generic}. We summarize the result in the following theorem.

% \begin{theorem}\label{thm:psica-to-psuca}
% 	Let $X$ and $Y$ be two arbitrary sets.
% 	For every adversary $\adv$ such that $\adv^{\PSICA(\cdot, Y)}(X) = X \cap Y$ which makes $q\in\mathbb{N}$ \PSICA{} evaluations,
% 	there is an an adversary $\bdv$ with oracle access to $\PSUCA(\cdot, Y)$ which recovers $X \cap Y$ and makes $q + 3$ \PSUCA{} evaluations. 
% \end{theorem}

% The proof can be found in Appendix~\ref{ap:psica-to-psuca}.

% % We now integrate the generic construction from \cref{fig:PSUCA_generic} into the \PSICAattack{} attack, which we introduced in \cref{ch:PSICA_attack}.
% % Recall that the attack starts by building a binary tree $T$ such that the root $T.\treeRoot$ holds the target set $X$ 
% % and the sets stored at the two children of any node in the tree form a partition of the set stored at their parent.
% % In particular, the immediate children of $T.\treeRoot$ store the sets $X_1$ and $X_2$, which form a partition of $X$. 
% % The attack then evaluates \PSICA{} on $X$ and $X_1$ (the latter happens in the first loop iteration) and computes $|X_2 \cap Y| = |X \cap Y| - |X_1 \cap Y|$.
% % This inference is not possible if the attacker can only evaluate \PSUCA{}, as it needs to know $m$.
% % However, using \cref{prop:PSUCA_comp_m} the attacker can determine $m$ by evaluating \PSUCA{} on $X$, $X_1$ and $X_2$ and 
% % then infer $|X \cap Y| = |X| + m - |X \cup Y|$ and $|X_i \cap Y| = |X_i| + m - |X_i \cup Y|$ for $i\in\{1,2\}$.
% % This is almost equivalent to how \PSICAattack{} attack processes the tree root and its two child nodes, 
% % with the difference that we require an additional evaluation of \PSUCA{} to determine $|X_2 \cap Y|$. 
% % After that, the attacker can carry out the rest of the PSI-CA attack, translating union to intersection cardinalities using \cref{eqn:union_intersect_cardinalities}.
% % The attack is shown in \cref{fig:PSUCA_attack}.
% % Note that in contrast to \PSICAattack{}, we maintain two sets $\posSet$ and $\negSet$, 
% % where $\posSet$ contains all elements of $X$ that belong to the intersection and $\negSet$ all elements that do not occur in $Y$.
% % This allows us to evaluate the performance of the attack in more detail under limited query budgets, see \cref{ch:experiments}. 
% % We state the correctness in the following theorem:

% % \begin{theorem}
% % 	Let $X$ and $Y$ be two arbitrary sets. 
% % 	$\PSUCAattack^{\PSUCA(\cdot, Y)}(X)$ outputs $X \cap Y$.
% % \end{theorem}
% % \begin{proof}
% % 	Follows directly from the correctness of \PSICAattack{} and \cref{prop:PSUCA_comp_m} and \cref{eqn:union_intersect_cardinalities}.
% % \end{proof}

% % \begin{figure}
% % 	\Wider[8em]{
% % 	\begin{pchstack}[boxed, center]
% % 		\procedure[linenumbering]{$\PSUCAattack^{\PSUCA(\cdot, Y)}(X)$}{
% % 			\text{Initialize empty set $\posSet$, $\negSet$.} \\
% % 			\text{Initialize max-priority queue $Q$.} \\
% % 			T \gets \mathsf{buildTree}(X) \\
% % 			T_L = T.\treeRoot.\treeLeftChild; \; T_R = T.\treeRoot.\treeRightChild \\
% % 			X_L = T_L.\treeSet; \; X_R = T_R.\treeSet \\
% % 			\gamechange{$z \gets \PSUCA(X, Y)$} \label{lin:PSUCA_attack_eval1} \\
% % 			\gamechange{$z_L \gets \PSUCA(X_L, Y)$} \label{lin:PSUCA_attack_eval2} \\
% % 			\gamechange{$z_R \gets \PSUCA(X_R, Y)$} \label{lin:PSUCA_attack_eval3} \\
% % 			\gamechange{$m \gets z_R - (z - z_L)$} \pccomment{\cref{prop:PSUCA_comp_m}} \\
% % 			\gamechange{$k \gets |X| + m - z$} \pccomment{\cref{eqn:union_intersect_cardinalities}}\\
% % 			\gamechange{$k_L \gets |X_L| + m - z_L$} \pccomment{\cref{eqn:union_intersect_cardinalities}}\\
% % 			\gamechange{$k_R \gets |X_R| + m - z_R$} \pccomment{\cref{eqn:union_intersect_cardinalities}}\\
% % 			\gamechange{$Q.\push(p_{\PSICA}(z_L, |X_L|), (T_L, k_L))$} \\
% % 			\gamechange{$Q.\push(p_{\PSICA}(z_R, |X_R|), (T_R, k_R))$} \\
% % 			\pcwhile Q \text{ is not empty} \pcdo \\
% % 			\t	(T_c, k_c) \gets Q.\pop() \pcskipln\\
% % 			\t	X_c \gets T_c.\treeSet \\
% % 			\t 	\pclinecomment{DFS path traversal} \\
% % 			\t	\pcwhile 0 < k_c < |X_c| \pcdo \label{lin:PSUCA_inner_while_condition} \\
% % 			\t	\t	T_L \gets T_c.\treeLeftChild; \; T_R \gets T_c.\treeRightChild \\
% % 			\t	\t	X_L \gets T_L.\treeSet; \; X_R \gets T_R.\treeSet \\
% % 			\t 	\t	\gamechange{$z_L \gets \PSUCA(X_L, Y)$} \\
% % 			\t	\t	\gamechange{$k_L \gets |X_L| + m - z_L$} \pccomment{\cref{eqn:union_intersect_cardinalities}} \\
% % 			\t	\t	k_R \gets k_c - k_L \\
% % 			\t	\t	p_L \gets p_{\PSICA}(k_L, |X_L|) \\
% % 			\t 	\t	p_R \gets p_{\PSICA}(k_R, |X_R|) \\
% % 			\t	\t	\pcif p_L > p_R \pcthen \pcskipln \\
% % 			\t	\t	\t	\pclinecomment{Continue with left child} \\
% % 			\t	\t	\t	T_c \gets T_L; \; k_c \gets k_L \\
% % 			\t	\t	\t	Q.\push(p_R, (T_R, k_R)) \\
% % 			\t	\t	\pcelse \pcskipln\\
% % 			\t	\t	\t	\pclinecomment{Continue with right child} \\
% % 			\t	\t	\t	T_c \gets T_R; \; k_c \gets k_R \\
% % 			\t	\t	\t	Q.\push(p_L, (T_L, k_L)) \\
% % 			\t	\pcif k_c = |X_c| \pcthen \label{lin:PSUCA_add_condition}\\
% % 			\t	\t	\posSet \gets \posSet \cup X_c \\
% % 			\t	\pcelse \\
% % 			\t	\t	\negSet \gets \negSet \cup X_c \\
% % 			\pcreturn \posSet, \negSet
% % 		}
% % 		\pchspace	
% % 		\procedure[linenumbering]{$\mathsf{buildTree}(\setT)$}{
% % 			\text{Initialize a tree $T$ with a single}\pcskipln\\
% % 			\pcparbox{node $\treeRoot$, which stores \setT. 
% % 			Build a balanced binary search tree by recursively dividing the set stored at a node 
% % 			into two disjoint subsets of roughly equal size.} \\
% % 			\pcreturn T
% % 		}
% % 	\end{pchstack}}
% % 	\caption{Intersection-recovery attack \PSUCAattack{} with oracle access to $\PSUCA(\cdot, Y)$ for a fixed victim set $Y$.
% % 	Note that $Y$ is part of the oracle and unknown to the adversary.
% % 	Changes to \PSICAattack{} are highlighted in gray.}\label{fig:PSUCA_attack}
% % \end{figure}

% % For our experimental evaluation in \cref{ch:experiments}, we additionally propose two further heuristics: 
% % $p_{\PSICA}^-$, which prioritizes the reconstruction of the set difference $X \setminus Y$ 
% % over that of the intersection,
% % and $p_{\PSICA}^*$, whose aim is to maximize the total (positive and negative) membership information we can infer.
% % In light of these additional definitions, we define the alias $p_{\PSICA}^+ := p_{\PSICA}$ to avoid confusion in the presentation of our experimental results.
% % $$p_{\PSICA}^-(k, |X|) := \frac{|X| - k}{|X|}$$
% % $$p_{\PSICA}^*(k, |X|) := \frac{\max(k, |X| - k)}{|X|}$$

% % \textbf{Time and Query Complexity.} 
% % We assume $n = |X|$ is a power of two. However, the analysis holds for general $n$; 
% % see the argument in the analysis of \PSICAattack{} in \cref{ch:PSICA_attack}.
% % As $n$ is a power of two, there are $\sum_{i=0}^{\log n} 2^i = 2n - 1$ nodes in $T$.
% % The two loops collectively visit each of these nodes at most once.
% % The body of the inner loop requires only constant time except for the $\push$ operation,
% % which requires amortized \bigO{\log n} time. 
% % This yields an overall time complexity of \bigO{n\log n}.

% % \PSUCAattack{} evaluates \PSUCA{} three times in lines~\ref{lin:PSUCA_attack_eval1}~-~\ref{lin:PSUCA_attack_eval3}.
% % Ignoring early terminations, the attack then makes further evaluations for at most half of the nodes in the rest 
% % of the binary search tree (excluding the root and its two direct children).
% % As mentioned above, there are $2n - 1$ nodes in $T$.
% % The attack therefore evaluates \PSUCA{} at most $(2n - 4) / 2 + 3 = n + 1$ times.
% % Recall from \cref{ch:PSICA_attack} that \PSICAattack{} makes at most $n$ \PSICA{} evaluations.
% % In the worst case, \PSUCAattack{} therefore requires two protocol invocations less than the generic construction in \cref{fig:PSUCA_generic}.
% % As is the case with \PSICAattack{}, we can expect this number to be lower due to the early termination of DFS path traversals.
% % See \cref{ch:experiments} for an empirical evaluations.


% \subsection{Applications to Private Record Matching}\label{sec:PSUCA_to_matching}
% % To highlight that our attacks extend beyond specific PSU or PSU-CA protocols, we
% % show in this section that the \PSUCAattack{} attack can be applied to the functionality of Meta's PrivateID protocol and 
% % -- with some additional assumptions -- also to the MKPM functionality we formalized in \cref{sec:prel_leakage}.

% % \subsection{PrivateID}\begin{figure}
% % 	\Wider[3em]{
% % 	\begin{tcolorbox}[colback=white,arc=0mm]
% % 	\begin{description}
% % 		\item[\textbf{Parameters:}] Two parties, $C$ and $P$.
% % 		\item[\textbf{Functionality} $\mathsf{SKPM}(X, Y)$:] \hfill \begin{enumerate}
% % 			\item Receive input sets $X$ from party $C$ and $Y$ from party $P$.
% % 			\item Compute $Z := X \cup Y$.
% % 			\item Sample an injective random function $f \sample \InjFuncs[\Ispace, \G]$.
% % 			\item Compute dictionaries $\MC : \G \to X \cup \{\bot\}$ and $\MP : \G \to Y \cup \{\bot\}$ such that for all $z \in Z$
% % 			\begin{equation*}
% % 				\MC[f(z)] = \begin{cases*}
% % 					z & if $z \in X$ \\
% % 					\bot & otw.
% % 				\end{cases*} \quad\text{and}\quad
% % 				\MP[f(z)] = \begin{cases*}
% % 					z & if  $z \in Y$ \\
% % 					\bot & otw.
% % 				\end{cases*}
% % 			\end{equation*}
% % 		\item Compute $\UID := \{f(z) \setdsc z \in Z\}$.
% % 		\item Send $(\UID, \MC)$ to $C$ and $(\UID, \MP)$ to $P$.
% % 		\end{enumerate}  
% % 	\end{description}
% % 	\end{tcolorbox}}
% % 	\caption{Single-Key Private Matching functionality, implemented by Meta's PrivateID protocol \cite{PMC}.}\label{fig:SKPM_definition}
% % \end{figure}

% % Meta's PrivateID protocol~\cite{PMC} implements the Single-Key Private Matching (SKPM) functionality, 
% % which is the single-key counterpart to the MKPM functionality we formalized in \cref{sec:prel_leakage}.
% % In this section, we give a brief overview of the SKPM functionality and then show that minimal modifications to \PSUCAattack{}
% % suffice to learn the intersection of its inputs.

% % SKPM involves two parties $C$ and $P$ 
% % with input sets $X \subseteq \Ispace{}$ and $Y \subseteq \Ispace{}$.
% % The functionality computes $Z := X \cup Y$ and renames the elements of $Z$ by evaluating them under an injective random function,
% % yielding the set \UID{}.
% % It then computes two maps $\MC: \UID \to X \cup \{\bot\}$ and $M_P: \UID \to Y \cup \{\bot\}$,
% % which map elements in $\UID$ to the original elements in $X$ and $Y$ or $\bot$ if the element only occurs in the other party's set. 
% % In the end, party $C$ receives $\UID$ and $\MC$ and party $P$ $\UID$ and $\MP$ correspondingly.
% % See \cref{fig:SKPM_definition} for the formal definition.

% % Clearly, we have $|\UID| = |X \cup Y|$ for any two sets $X$ and $Y$.
% % We can therefore apply \PSUCAattack{} directly to SKPM 
% % to recover $X \cap Y$ in at most $|X| + 1$ SKPM evaluations.
% % Guo et al.~\cite{Guo22} have already examined PrivateID in the context of their intersection recovery attack on \PSICA{},
% % where they recover $X \cap Y$ in at most $|X|$ protocol invocations.
% % However, they rely on the fact that PrivateID leaks $|X \cap Y|$ during the protocol execution, 
% % while our attack relies on the functionality output alone.

% % \subsection{MK-PrivateID}
% % Meta's MK-PrivateID protocol~\cite{MPMC} implements the Multi-Key Private Matching (MKPM) functionality we defined in \cref{sec:prel_leakage}.
% % We show in this section, how \PSUCAattack{} can be applied to MKPM to 
% % learn, which records in the target set contain an identifier that also occurs in the victim set.
% % This corresponds the \emph{Matchable Record Recovery} goal we formalized in \cref{sec:MRR_goal}.
% % Recall that the attacker is given a set of records \setT{}, the target set, and can evaluate $\MKPM(\setT', \setV)$
% % for arbitrarily many inputs $\setT'$, while the victim set \setV{} remains static.
% % The adversary's goal is to determine the set $\setT \sqcap \setV = \{t \in \setT \setdsc \exists v \in \setV\; \exists i,k \in \N : t[i] = v[k]\}$.

% % Similar to its single-key counterpart SKPM, 
% % MKPM outputs a set $\UID$. However, instead of assigning a common uid to two identical records it matches records
% % using a matching logic (see \cref{fig:match_logic}) and assigns a common uid to pairs of matching records,
% % as well as a separate uid to every unmatched record in \setT{} and \setV{}.
% % Thus, taking $|\UID|$ as the the union cardinality to carry out \PSUCAattack{} seems to be a natural approach 
% % to identify matching records in \setT{}.
 
% % Recall that the \PSUCAattack{} attack relies on the observation that $|X \cap Y| = |X_1 \cap Y| + |X_2 \cap Y|$,
% % where $X$ and $Y$ are arbitrary sets and $X_1, X_2$ form a partition of $X$.
% % Applying \cref{eqn:union_intersect_cardinalities}, this is equivalent to $|X \cup Y| = |X_1 \cup Y| + |X_2 \cup Y| - |Y|$.
% % Translating this to the multi-key setting, let $\setX \subseteq \setT$ and let $\setX_1, \setX_2$ be a partition of \setX{}.
% % Moreover, let \UID{}, $\UID_1$, and $\UID_2$ result from evaluating $\MKPM(\setX, \setV)$ and $\MKPM(\setX_i, \setV)$ for $i \in \{1,2\}$ respectively.
% % Then, the following relation needs to hold:
% % \begin{equation}
% % 	\label{eqn:MKPM_PSUCA_condition}
% % 	|\UID| = |\UID_1| + |\UID_2| - |\setV|
% % \end{equation}

% % Unfortunately, this does not hold for general inputs for two reasons.
% % First, as we elaborated in \cref{sec:MRR_goal}, the MKPM functionality shuffles the inputs before 
% % evaluating the matching logic on them. 
% % As a result, the record matching logic does not consistently match the same number of records in different protocol runs for some fixed inputs,
% % i.e., different evaluations of \MKPM{} with the same inputs result in \UID{} sets with different cardinalities.
% % And second, the matching logic violates \cref{eqn:MKPM_PSUCA_condition} even in cases where shuffling the inputs has no effect on the former.

% % Consider the situation depicted in \cref{fig:MPMK_PSUCA_counterexample}.
% % On the left, we show an example of a target set \setT{} and victim set \setV{}, 
% % where two records in the target set share an identifier with the same record in the victim set.
% % We call this a \emph{many-to-one relation}.
% % Recall that the matching logic uses the order of identifiers in \setT{} as priorities to resolve such many-to-one relations.
% % That is, it matches the second target record with the victim record, since it shares its first identifier $\id_3$ with the victim record,
% % as opposed to the first target record, which shares its second identifier with the victim record. The latter remains unmatched.
% % The resulting set \UID{} therefore contains two elements: 
% % one uid for the two matched records and one for the unmatched first target record.
% % On the right, we show a partition of \setT{}, matched against the same victim set \setV{} (in two separate protocol invocations).
% % Now isolated and lacking competition from the other record, both target records are matched.
% % The resulting sets $\UID_1$ and $\UID_2$ therefore both contain one uid.
% % That is, we have $|\UID| = |\UID_1| + |\UID_2| \neq |\UID_1| + |\UID_2| - |\setV|$, which violates the requirement mentioned above.

% % \begin{figure}
% % 	\centering
% % 	{\def\linecorr{-.4pt}
% % 	\def\rowspace{\linecorr}
% % 	\def\colspace{1.2cm}
% % 	\def\setspace{5cm}
% % 	\def\setvertspace{.5cm}
% % 	\def\minwidthid{.6cm}
% % 	\def\blockminheight{1.3em}
% % 	\begin{tikzpicture}
% % 		[block/.style={draw,minimum width=#1, minimum height=\blockminheight,font={\tiny}},
% % 		%block/.default=10em,high/.style={minimum height=3em},auto,
% % 		block/.default=10em,high/.style={},auto,
% % 		node distance=0, % initially 1cm
% % 		>=Stealth]
% % 		%node distance=5em,auto]
% % 		% Nodes
% % 		\node[block=\minwidthid,fill=trow-dark] (alice1) {$\id_1$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of alice1] (alice2) {$\id_2$};

% % 		\node[block=\minwidthid,fill=trow-light, below=\rowspace of alice1] (bob1) {$\id_3$};
% % 		\node[block=\minwidthid,fill=trow-light, right=\linecorr of bob1] (bob2) {$\id_4$};

% % 		\coordinate (mid) at ($(alice2)!0.5!(bob2)$);

% % 		\node[block=\minwidthid,fill=trow-dark, right=\colspace of mid] (vic1) {$\id_3$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vic1] (vic2) {$\id_2$};

% % 		\coordinate (right-center) at ([xshift=(\setspace)]mid);


% % 		\node[block=\minwidthid,fill=trow-dark, above=\setvertspace of right-center] (alicesub1) {$\id_1$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of alicesub1] (alicesub2) {$\id_2$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\colspace of alicesub2] (vicsub1) {$\id_3$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vicsub1] (vicsub2) {$\id_2$};

% % 		\node[block=\minwidthid,fill=trow-dark, below=\setvertspace of right-center] (bobsub1) {$\id_3$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of bobsub1] (bobsub2) {$\id_4$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\colspace of bobsub2] (vicsub3) {$\id_3$};
% % 		\node[block=\minwidthid,fill=trow-dark, right=\linecorr of vicsub3] (vicsub4) {$\id_2$};

% % 		% Connections
% % 		\draw[dashed] (alice2) to (vic1);
% % 		\draw (bob2) to (vic1);

% % 		\draw (alicesub2) to (vicsub1);
% % 		\draw (bobsub2) to (vicsub3);

% % 		% \labels and descriptions
% % 		\coordinate (center1) at ($(alice2.south east)!0.5!(vic1.west)$);
% % 		\coordinate (center2) at ($(alicesub2.east)!0.5!(vicsub1.west)$);
% % 		\coordinate (center3) at ($(bobsub2.east)!0.5!(vicsub3.west)$);

% % 		\node[above=.3cm of alice1.east] (Tlabel) {\tiny$\setT$};
% % 		\node[above=.3cm of vic1.east] (Vlabel1) {\tiny$\setV$};
% % 		\node[below=.6cm of center1] (UIDlabel) {\tiny$|\UID| = 2$};
		
% % 		\node[above=.3cm of alicesub1.east] (Tlabel2) {\tiny$\setT_1$};
% % 		\node[above=.3cm of vicsub1.east] (Vlabel2) {\tiny$\setV$};
% % 		\node[below=.3cm of center2] (UIDlabel1) {\tiny$|\UID_1| = 1$};
		
% % 		\node[above=.3cm of bobsub1.east] (Tlabel3) {\tiny$\setT_2$};
% % 		\node[above=.3cm of vicsub3.east] (Vlabel3) {\tiny$\setV$};
% % 		\node[below=.3cm of center3] (UIDlabel2) {\tiny$|\UID_2| = 1$};
% % 	\end{tikzpicture}}
% % 	\caption{Example of a target set \setT{} and victim set \setV, where \PSUCAattack{} cannot be applied.
% % 	Lines between records indicate potential matches based on matching identifiers. 
% % 	Solid lines denote the matched records chosen by the matching logic.
% % 	Clearly, $|\UID| \neq |\UID_1| + |\UID_2| - |\setV|$.}
% % 	\label{fig:MPMK_PSUCA_counterexample}
% % \end{figure}
% % To avoid such cases, we formalize a restriction on the input sets that 
% % -- if satisfied -- allows us to carry out the attack.
% % Conveniently, the opposite case, where one record in the target set shares identifiers with multiple records in the victim set,
% % does not lead to such problems.
% % It therefore suffices to exclude many-to-one relations.

% % \begin{definition}[Isolated Set]\label{def:isolated_set}
% % 	Let \setX{} and \setY{} be two sets of records $\setX, \setY \subseteq \Ispace{}^{\leq k}$ for some $k\in\N$.
% % 	We say \setX{} is \emph{$\setY$-isolated}, 
% % 	if for all $v\in \setY$ we have $|\{t \in \setX \setdsc \exists i, j. \; t[i] = v[j]\}| \leq 1$.
% % \end{definition}

% % This additional constraint on the protocol inputs excludes some realistic scenarios.
% % For instance, if the sets contain IP addresses
% % -- IPv4 addresses behind a Network Address Translation (NAT) device in particular --
% % such many-to-one relations are likely to occur, as users in the same local network share an address.
% % However, this does not exclude the scenarios outlined in \cref{sec:threat_model},
% % where the adversary chooses a specific range of identifiers as its target set, 
% % such as all phone numbers of a certain area code or all email addresses belonging to some domain.
% % Furthermore, scenarios where users possess multiple identifiers of some type,
% % e.g., a private and a work email address, 
% % but do not share them with other people, are still admitted as well, 
% % provided that each user's identifiers only occur in at most one record in the target set.
% % \cref{def:isolated_set} conveniently resolves both issues outlined above,
% % which we prove in the following two lemmas.

% % \begin{lemma}
% % 	\label{lem:set_isolation_determinism}
% % 	Let $\setX, \setY \subseteq \Ispace{}^{\leq k}$ be two sets of records. 
% % 	If \setX{} is \setY-isolated, 
% % 	the cardinality of $\UID$ output by $\MKPM(\setX, \setY)$ (\cref{fig:MKPM}) is consistent across multiple evaluations.
% % \end{lemma}
% % \begin{proof}
% % 	For any $x \in \setX$, let $\setY_x$ denote the records of \setY{} that share at least one identifier with $x$,
% % 	i.e., $\setY_x := \{y \in \setY \setdsc \exists i, j \in \N : x[i] = y[j]\}$.
% % 	If \setX{} is $\setY$-isolated, we have that $\setY_x \cap \setY_{x'} = \emptyset$ for all $x, x' \in \setX$ with $x \neq x'$. 
% % 	Therefore, there exist no two records in \setX{} that could be matched with the same record in \setY{}.
	
% % 	We first consider sets $\setY_x$ that are not empty.
% % 	Since $x$ can only be matched with some $y \in \setY_x$ and all $y \in \setY_x$ can only be matched with $x$,
% % 	\match{} (\cref{fig:match_logic}) will match $x$ with exactly one $y_x \in \setY_x$,
% % 	which are assigned the same uid (line~\ref{lin:match_common_uid}).
% % 	All other $y \in \setY_x$, i.e., $y \neq y_x$, will remain unmatched and are assigned their own uid (line~\ref{lin:match_unmatched_P_uid}).
% % 	Furthermore, all $y \in \setY$ which do not belong to any $\setY_{x'}$ for any $x' \in \setX$ will also remain unmatched and are assigned their own uid (also line~\ref{lin:match_unmatched_P_uid}).
% % 	Lastly, all $x\in\setX$ for which $\setY_x = \emptyset$ will remain unmatched and receive their own uid (line~\ref{lin:match_unmatched_C_uid}). 
	
% % 	Thus, \UID{} contains one uid for each $y\in \setY$ and one uid for each unmatched $x\in \setX$, i.e.,
% % 	$|\UID| = |\setY| + |\{x \in \setX \setdsc \setY_x = \emptyset\}|$.
% % 	This is independent of the order of the records in \setX{} and \setY{} and
% % 	thus also independent of the shuffling done before the matching step in \MKPM{}.
% % 	Since \MKPM{} only uses randomness to shuffle the inputs, we have proven the lemma.
% % \end{proof}

% % \begin{lemma}
% % 	\label{lem:set_isolation_inference}
% % 	Let \setX{} and $\setY \subseteq \Ispace{}^{\leq k}$ be two sets of records and let $\setX_1$ and $\setX_2$
% % 	be a partition of $\setX$. 
% % 	Moreover, let $(\UID, \MC) \sample \MKPM(\setX, \setV)$ and $(\UID_i, M_{C,i}) \sample \MKPM(\setX_i, \setV)$ for $i \in \{1,2\}$.
% % 	If $\setX$ is \setY-isolated, we have $|\UID| = |\UID_1| + |\UID_2| - |\setY|$.
% % \end{lemma}
% % \begin{proof}
% % 	We show this by induction on $|\setX_1|$.
% % 	If $|\setX_1| = 0$ all records of $\setY$ are unmatched and, thus, $|\UID_1| = |Y|$.
% % 	Note that $\setX_2 = \setX$ and thus we have $|\UID| = |\UID_2| = |\UID_2| + |\UID_1| - |Y|$.
% % 	In the first equality, we use \cref{lem:set_isolation_determinism}. 

% % 	Assume $|\setX_1| = n_1$ for some $n_1 > 0$ and $|\UID| = |\UID_1| + |\UID_2| - |\setY|$.
% % 	Since $\setX_1$ and $\setX_2$ form a partition of $\setX$, we must move a record from $\setX_2$ to $\setX_1$
% % 	to achieve $|\setX_1| = n_1+1$. Note that $|\UID|$ remains unchanged due to \cref{lem:set_isolation_determinism}.
% % 	Let $x \in \setX_2$ and let $\setX'_1 := \setX_1 \cup \{x\}$ and $\setX'_2 := \setX_2 \setminus \{x\}$.
% % 	Moreover, let $\UID'_1$ and $\UID'_2$ be the sets of UIDs resulting from evaluating $\MKPM(\setX'_1, \setY)$ and $\MKPM(\setX'_2, \setY)$. 
% % 	We distinguish two cases.
% % 	If no identifier of $x$ occurs in $\setY$, $x$ was assigned its own UID.
% % 	Therefore, $|\UID'_1| = |\UID_1| + 1$ and $|\UID'_2| = |\UID_2| - 1$, which implies the claim.
	
% % 	For the second case, assume $x$ shares some identifiers with $n^*$ records of $\setY$.
% % 	Call this set $\setY_x$.
% % 	Since \setX{} is \setY-isolated, all records $y \in \setY_x$ only share identifiers with $x$,
% % 	but no other $x'\in \setX_2$.
% % 	Thus, $x$ is matched with some $y^* \in \setY_x$,
% % 	i.e., $x$ and $y^*$ are assigned the same $\uid \in \UID_2$.
% % 	After removing $x$ from $\setX_2$, $y^*$ will still be assigned some $\uid' \in \UID'_2$, 
% % 	which it does not share with any $x' \in \setX'_2$, again since $\setX$ is \setY-isolated. 
% % 	Therefore, $|\UID_2| = |\UID'_2|$. 
% % 	Similarly, since $x\not\in \setX_1$, no $y\in \setY_x$ and $x' \in \setX_1$ are assigned the same $\uid \in \UID_1$.
% % 	By the definition of $\setY_x$ and since \setX{} is \setY-isolated, $x$ will be assigned the same $\uid\in \UID'_1$
% % 	as some $y\in\setY_x$ after being added to $\setX_1$, implying $|\UID_1| = |\UID'_1|$.
% % 	The claim then follows trivially.
% % \end{proof}

% % With the necessary properties of isolated input sets established, we can assert the correctness of our adaptation:

% % \begin{theorem}
% % 	Let \setT{} and \setV{} be two sets of records.
% % 	If \setT{} is \setV{}-isolated, then \\
% % 	$\PSUCAattack^{\MKPM(\cdot, \setV)}(\setT)$ recovers $\setT \sqcap \setV$.
% % \end{theorem}
% % \begin{proof}
% % 	Let \posSet{} and \negSet{} be the two sets output by $\PSUCAattack^{\MKPM(\cdot, \setV)}(\setT)$.
% % 	Note all records of \setT{} are contained in some subset $\setT_c\subseteq \setT$ that will eventually reach line~\ref{lin:PSUCA_add_condition},
% % 	since the attack only terminates once the priority queue is empty. 
% % 	Therefore, every record of \setT{} is added to either \posSet{} or \negSet{}.
% % 	For any $\setT_c$ reaching line~\ref{lin:PSUCA_add_condition} 
% % 	we have that either (1) $k_c = |\setT_c|$ or (2) $k_c  = 0$ by the loop condition on line~\ref{lin:PSUCA_inner_while_condition}.
% % 	Let $\UID_c$result from evaluating $\MKPM(\setT_c, \setV)$.
% % 	By \cref{eqn:union_intersect_cardinalities} and \cref{lem:set_isolation_inference}, we have $k_c = |\setT_c| + |\setV| - |\UID_c|$.
% % 	\begin{description}
% % 		\item[Case (1)] If $k_c = |\setT_c|$, then we have $|\UID_c| = |\setV|$, i.e., all records of $\setT_c$ are matched. 
% % 		Since records are only added to \posSet{} if this case applies, we have $\posSet \subseteq \setT \sqcap \setV$.
% % 		\item[Case (2)] If $k_c = 0$, then $|\UID_c| = |\setT_c| + |\setV|$, i.e., no records of $\setT_c$ 
% % 		were matched. Therefore, no record in $\setT_c$ shares any identifiers with any record in $\setV{}$.
% % 		Since records are only added to \negSet{} if this case applies, we have $\negSet \subseteq \setT \setminus (\setT \sqcap \setV)$. 
% % 	\end{description}
% % 	We have therefore shown that \posSet{} only contains matchable records, \negSet{} only contains non-matchable records 
% % 	and that every record in \setT{} is contained in either \posSet{} or \negSet{}.
% % 	This proves the theorem.
% % \end{proof}


% % \textbf{Time and Query Complexity.}
% % The adaptations described above merely consist of translating the notion of a set union cardinality to the multi-key scenario.
% % In particular, the elements of $X$ that lie in the intersection $X\cap Y$ are analogous
% % to the matchable records in \setT{} and \PSUCAattack{} behaves identically in the two settings.
% % It therefore also has the same worst-case time complexity and maximum number of MKPM evaluations.
% % Due to said correspondence between $X \cap Y$ and the matched records of \setT{}, 
% % we can expect the actual number of functionality evaluations for any given intersection size 
% % (or number of matchable records) to be similar.